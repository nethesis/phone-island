{"version":3,"file":"conference.js","sources":["../../src/models/conference.ts"],"sourcesContent":["// Copyright (C) 2025 Nethesis S.r.l.\n// SPDX-License-Identifier: AGPL-3.0-or-later\n\nimport { createModel } from '@rematch/core'\nimport type { RootModel } from '.'\n\nexport interface ConferenceUser {\n  id: string\n  name: string\n  owner: boolean\n  muted: boolean\n  extenId: string\n  joinTime?: number\n}\n\nexport interface ConferenceStoreTypes {\n  usersList: Record<string, ConferenceUser> | null\n  ownerInformations: ConferenceUser | null\n  isActive: boolean\n  conferenceStartedFrom: string\n  conferenceStartTime: any\n  isOwnerInside?: boolean\n  isConferenceMuted: boolean\n  conferenceId: string\n}\n\nconst defaultState: ConferenceStoreTypes = {\n  usersList: null,\n  ownerInformations: null,\n  isActive: false,\n  conferenceStartedFrom: '',\n  conferenceStartTime: null,\n  isOwnerInside: false,\n  isConferenceMuted: false,\n  conferenceId: '',\n}\n\nexport const conference = createModel<RootModel>()({\n  state: defaultState,\n  reducers: {\n    updateConferenceUsersList: (state, payload: Record<string, ConferenceUser>) => {\n      // Search for the owner\n      let owner: ConferenceUser | null = null\n\n      // Determine if the conference is active\n      const isActive = !!payload && Object.keys(payload).length > 0\n\n      // Prepare updated user list with join timestamps\n      let updatedUsersList: Record<string, ConferenceUser> = {}\n\n      if (payload) {\n        const currentTime = Date.now()\n\n        // Process each user in the payload\n        Object.entries(payload).forEach(([userId, user]) => {\n          // Check if this user already exists in the current usersList\n          const existingUser = state.usersList?.[userId]\n\n          // Preserve existing user data: joinTime and muted status\n          updatedUsersList[userId] = {\n            ...user,\n            joinTime: existingUser?.joinTime || currentTime,\n            // Keep existing muted status if user already exists\n            muted: existingUser ? existingUser.muted : user.muted,\n          }\n\n          // Find the owner\n          if (user.owner) {\n            owner = {\n              ...user,\n              joinTime: existingUser?.joinTime || currentTime,\n              // Keep existing muted status for owner if it exists\n              muted: existingUser ? existingUser.muted : user.muted,\n            }\n          }\n        })\n      }\n\n      // Update the start time if the conference is becoming active and wasn't before\n      const conferenceStartTime =\n        !state.isActive && isActive ? Date.now() : state.conferenceStartTime\n\n      return {\n        ...state,\n        usersList: updatedUsersList,\n        ownerInformations: owner,\n        isActive: isActive,\n        conferenceStartTime: isActive ? conferenceStartTime : null,\n      }\n    },\n    updateOwnerInformations: (state, payload: ConferenceUser | null) => {\n      return {\n        ...state,\n        ownerInformations: payload,\n      }\n    },\n    setConferenceActive: (state, isActive: boolean) => {\n      return {\n        ...state,\n        isActive,\n        conferenceStartTime:\n          isActive && !state.conferenceStartTime ? Date.now() : state.conferenceStartTime,\n      }\n    },\n    setConferenceStartedFrom: (state, conferenceStartedFrom: string) => {\n      return {\n        ...state,\n        conferenceStartedFrom,\n      }\n    },\n    resetTimer: (state) => {\n      return {\n        ...state,\n        conferenceStartTime: Date.now(),\n      }\n    },\n    resetFirstUserFlag: (state) => {\n      return {\n        ...state,\n        isFirstUser: false,\n      }\n    },\n    toggleUserMuted: (state, payload: { extenId: string; muted?: boolean }) => {\n      const { extenId, muted } = payload\n\n      if (!state.usersList || !state.usersList[extenId]) {\n        return state\n      }\n\n      const updatedUsersList = { ...state.usersList }\n\n      updatedUsersList[extenId] = {\n        ...updatedUsersList[extenId],\n        muted: muted !== undefined ? muted : !updatedUsersList[extenId].muted,\n      }\n\n      let updatedOwnerInformations = state.ownerInformations\n      if (state.ownerInformations && state.ownerInformations.extenId === extenId) {\n        updatedOwnerInformations = {\n          ...state.ownerInformations,\n          muted: updatedUsersList[extenId].muted,\n        }\n      }\n\n      return {\n        ...state,\n        usersList: updatedUsersList,\n        ownerInformations: updatedOwnerInformations,\n      }\n    },\n    toggleIsOwnerInside: (state, isOwnerInside: boolean) => {\n      return {\n        ...state,\n        isOwnerInside,\n      }\n    },\n    toggleIsConferenceMuted: (state, isConferenceMuted: boolean) => {\n      return {\n        ...state,\n        isConferenceMuted,\n      }\n    },\n    updateConferenceId: (state, conferenceId: string) => {\n      return {\n        ...state,\n        conferenceId,\n      }\n    },\n    resetConference: () => defaultState,\n  },\n})\n"],"names":["defaultState","usersList","ownerInformations","isActive","conferenceStartedFrom","conferenceStartTime","isOwnerInside","isConferenceMuted","conferenceId","conference","createModel","state","reducers","updateConferenceUsersList","payload","owner","Object","keys","length","updatedUsersList","currentTime_1","Date","now","entries","forEach","_a","userId","user","existingUser","_b","__assign","joinTime","muted","updateOwnerInformations","setConferenceActive","setConferenceStartedFrom","resetTimer","resetFirstUserFlag","isFirstUser","toggleUserMuted","extenId","undefined","updatedOwnerInformations","toggleIsOwnerInside","toggleIsConferenceMuted","updateConferenceId","resetConference"],"mappings":"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"}