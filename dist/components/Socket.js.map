{"version":3,"file":"Socket.js","sources":["../../src/components/Socket.tsx"],"sourcesContent":["// Copyright (C) 2024 Nethesis S.r.l.\n// SPDX-License-Identifier: AGPL-3.0-or-later\n\nimport React, { type ReactNode, FC, useEffect, useRef } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { Dispatch, RootState } from '../store'\nimport { io } from 'socket.io-client'\nimport { getDisplayName } from '../lib/phone/conversation'\nimport { getCurrentUserInfo } from '../services/user'\nimport {\n  dispatchMainPresence,\n  dispatchConversations,\n  dispatchQueueUpdate,\n  dispatchQueueMemberUpdate,\n  dispatchAlreadyLogin,\n  dispatchServerReload,\n  dispatchParkingUpdate,\n  dispatchExtensions,\n  dispatchUrlCall,\n  dispatchDefaultDeviceUpdate,\n} from '../events'\nimport { store } from '../store'\nimport { eventDispatch, withTimeout } from '../utils'\nimport type {\n  ConversationTypes,\n  ExtensionTypes,\n  QueuesUpdateTypes,\n  QueueUpdateMemberTypes,\n  MainPresenceTypes,\n} from '../types'\nimport { getTimestampInSeconds } from '../utils/genericFunctions/timestamp'\nimport { userTotallyFree } from '../lib/user/extensions'\nimport { isEmpty } from '../utils/genericFunctions/isEmpty'\nimport { isPhysical } from '../lib/user/default_device'\nimport { ScreenSharingMessage } from './VideoView'\nimport { checkMediaPermissions } from '../lib/devices/devices'\nimport { isFromStreaming } from '../utils/streaming/isFromStreaming'\nimport { getStreamingSourceId } from '../utils/streaming/getStreamingSourceId'\nimport { subscribe } from '../services/user'\nimport { isFromTrunk } from '../lib/user/extensions'\n\ninterface SocketProps {\n  children: ReactNode\n  hostName: string\n  username: string\n  authToken: string\n  reload: boolean\n  reloadedCallback: () => void\n  uaType: string\n}\n\nexport const Socket: FC<SocketProps> = ({\n  hostName,\n  username,\n  authToken,\n  reload,\n  reloadedCallback,\n  children,\n  uaType,\n}) => {\n  const dispatch = useDispatch<Dispatch>()\n  const connectionCheckInterval = useRef<any>()\n  const socket = useRef<any>()\n  const isUpdatingUserInfo = useRef(false)\n\n  // get user information\n  const userInformation = useSelector((state: RootState) => state.currentUser)\n\n  const checkDefaultDeviceConversationActive = (conv: any) => {\n    dispatch.currentCall.updateCurrentCall({\n      conversationId: conv.id,\n      accepted: true,\n      incoming: conv.direction === 'in' ? false : undefined,\n    })\n    eventDispatch('phone-island-call-answered', {})\n\n    // Stop the local audio element ringing\n    store.dispatch.player.stopAudioPlayer()\n    store.dispatch.player.setAudioPlayerLoop(false)\n  }\n\n  const checkDefaultDeviceConversationClosed = (conv: any) => {\n    // store.dispatch.player.stopAudioPlayer()\n    store.dispatch.currentCall.reset()\n    // store.dispatch.listen.reset()\n  }\n\n  useEffect(() => {\n    /**\n     * Helper function to handle streaming source detection and subscription\n     */\n    const handleStreamingSource = (conv: ConversationTypes) => {\n      // Check if the call is from a streaming source\n      if (conv.counterpartNum && isFromStreaming(conv.counterpartNum)) {\n        // Set isFromStreaming flag to true\n        dispatch.island.setIsFromStreaming(true)\n\n        // Store the streaming source number in the currentCall state for future reference\n        dispatch.currentCall.updateCurrentCall({\n          streamingSourceNumber: conv.counterpartNum,\n        })\n\n        // Find the source ID and subscribe to streaming updates\n        const sourceId = getStreamingSourceId(conv.counterpartNum)\n        if (sourceId) {\n          // Subscribe to streaming updates\n          subscribe({ id: sourceId }).catch((error) =>\n            console.error('Error subscribing to streaming source:', error),\n          )\n        }\n      }\n    }\n\n    /**\n     * Manages event and data for the currentUser\n     *\n     * @param res The data from the socket\n     * @param conv The conversation data\n     */\n    const handleCurrentUserEvents = (res: ExtensionTypes, conv: ConversationTypes) => {\n      // Handle transferring data\n      const { transferring, transferSwitching, transferCalls } = store.getState().currentCall\n\n      const view = store.getState().island.view\n      // Check conversation isn't empty\n      if (Object.keys(conv).length > 0) {\n        // With conversation\n        if (res.status) {\n          const { extensions } = store.getState().users\n          const { default_device } = store.getState().currentUser\n          const { endpoints, username } = store.getState().currentUser\n          const { incoming, outgoing } = store.getState().currentCall\n\n          const hasOnlineNethlink = () => {\n            if (!extensions || !username) return false\n\n            // Get all extensions for current user\n            const userExtensions: any = Object.values(extensions).filter(\n              (ext) => ext?.username === username,\n            )\n\n            // Check if any extension is nethlink type and online\n            return userExtensions?.some((ext) => {\n              const endpointExtension = endpoints?.extension.find(\n                (endpoint) => endpoint.id === ext?.exten,\n              )\n              return endpointExtension?.type === 'nethlink' && ext?.status !== 'offline'\n            })\n          }\n          switch (res.status) {\n            case 'ringing':\n              // Handle streaming source for incoming calls\n              handleStreamingSource(conv)\n\n              if (\n                (uaType === 'mobile' && hasOnlineNethlink()) ||\n                (uaType === 'desktop' &&\n                  (default_device?.type === 'webrtc' ||\n                    (default_device?.type === undefined && !hasOnlineNethlink()) ||\n                    (!hasOnlineNethlink() && default_device?.type === 'physical')))\n              ) {\n                // Get updated user info\n                if (!isUpdatingUserInfo.current) {\n                  isUpdatingUserInfo.current = true\n                  getCurrentUserInfo()\n                    .then((userInfo) => {\n                      if (userInfo) {\n                        dispatch.currentUser.updateCurrentUser(userInfo)\n                        if (userInfo.settings && userInfo.settings.open_param_url) {\n                          dispatch.paramUrl.setOpenParamUrlType(userInfo.settings.open_param_url)\n                        } else {\n                          dispatch.paramUrl.setOpenParamUrlType('never')\n                        }\n                      }\n                    })\n                    .catch((error) => {\n                      console.error('Error getting current user info:', error)\n                    })\n                    .finally(() => {\n                      setTimeout(() => {\n                        isUpdatingUserInfo.current = false\n                      }, 100)\n                    })\n                }\n                dispatch.currentCall.checkIncomingUpdatePlay({\n                  conversationId: conv.id,\n                  displayName: getDisplayName(conv),\n                  number: `${conv.counterpartNum}`,\n                  incomingSocket: true,\n                  incoming: true,\n                  username:\n                    `${\n                      extensions &&\n                      extensions[conv.counterpartNum] &&\n                      extensions[conv.counterpartNum].username\n                    }` || '',\n                  ownerExtension: conv.owner,\n                })\n                let callInformations = {\n                  conversationId: conv.id,\n                  displayName: getDisplayName(conv),\n                  counterpartNum: `${conv.counterpartNum}`,\n                  ownerExtension: conv.owner,\n                  username:\n                    `${\n                      extensions &&\n                      extensions[conv.counterpartNum] &&\n                      extensions[conv.counterpartNum].username\n                    }` || '',\n                  chDest: conv?.chDest || {},\n                  chSource: conv?.chSource || {},\n                  direction: conv.direction,\n                  inConference: conv.inConference,\n                  linkedId: conv.linkedId,\n                  uniqueId: conv.uniqueId,\n                  throughQueue: conv.throughQueue,\n                  throughTrunk: conv.throughTrunk,\n                  recording: conv.recording,\n                }\n                store.dispatch.island.setIslandView('call')\n\n                eventDispatch('phone-island-call-ringing', {})\n                const { openParamUrlType } = store.getState().paramUrl\n                const { urlOpened } = store.getState().island\n\n                if (openParamUrlType === 'ringing' && !urlOpened) {\n                  // Calculate throughTrunk based on counterpartNum\n                  const calculatedThroughTrunk = isFromTrunk(conv.counterpartNum)\n\n                  // Update throughTrunk in paramUrl store\n                  store.dispatch.paramUrl.setThroughTrunk(calculatedThroughTrunk)\n\n                  store.dispatch.island.setUrlOpened(false)\n                  eventDispatch('phone-island-url-parameter-opened', {\n                    counterpartNum: conv.counterpartNum,\n                    counterpartName: getDisplayName(conv),\n                    owner: conv.owner,\n                    uniqueId: conv.uniqueId,\n                    throughQueue: conv.throughQueue,\n                    throughTrunk: calculatedThroughTrunk,\n                    direction: conv.direction,\n                    connected: conv.connected,\n                  })\n                }\n              }\n              break\n            // @ts-ignore\n            case 'busy':\n              // Handle streaming source for outgoing calls\n              handleStreamingSource(conv)\n\n              if (\n                (uaType === 'mobile' && hasOnlineNethlink()) ||\n                (uaType === 'desktop' &&\n                  (default_device?.type === 'webrtc' ||\n                    (default_device?.type === undefined && !hasOnlineNethlink()) ||\n                    (!hasOnlineNethlink() && default_device?.type === 'physical')))\n              ) {\n                if (conv && conv.connected) {\n                  // Current call accepted and update connected call\n                  dispatch.currentCall.updateCurrentCall({\n                    conversationId: conv.id,\n                    displayName: getDisplayName(conv),\n                    number: `${conv.counterpartNum}`,\n                    ownerExtension: conv.owner,\n                    username:\n                      `${\n                        extensions &&\n                        extensions[conv.counterpartNum] &&\n                        extensions[conv.counterpartNum].username\n                      }` || '',\n                    chDest: conv?.chDest || {},\n                    chSource: conv?.chSource || {},\n                  })\n                  // Update the current call informations for physical devices\n                  dispatch.currentCall.checkAcceptedUpdate({\n                    acceptedSocket: true,\n                  })\n                  // Add call to transfer calls\n                  dispatch.currentCall.addTransferCalls({\n                    type: 'transferred',\n                    displayName: getDisplayName(conv),\n                    number: `${conv.counterpartNum}`,\n                    startTime: `${getTimestampInSeconds()}`,\n                  })\n\n                  // Check if this is a streaming call that was accepted\n                  const { isFromStreaming } = store.getState().island\n                  if (isFromStreaming && conv.direction === 'out') {\n                    // Set view to streamingAnswer for outgoing streaming calls when accepted\n                    setTimeout(() => {\n                      dispatch.island.setIslandView('streamingAnswer')\n                    }, 200)\n                  }\n\n                  if (isPhysical()) {\n                    checkDefaultDeviceConversationActive(conv)\n                  }\n                  if (view === 'call' && transferring) {\n                    dispatch.currentCall.updateCurrentCall({\n                      transferring: false,\n                    })\n                  }\n                }\n                // Delete transfer calls if there are more than one ( in case of call switch after transfer)\n                if (transferCalls.length > 1) {\n                  dispatch.currentCall.deleteTransferCalls()\n                }\n                // Handle not connected calls\n                else if (conv && !conv.connected) {\n                  if (transferring && !transferSwitching) {\n                    // Handle hangup during transfer\n                    const inTransferCalls = transferCalls.find(\n                      (item) => item.number === conv.counterpartNum,\n                    )\n                    if (!conv.connected && inTransferCalls) {\n                      // Update transferring data for the current call\n                      dispatch.currentCall.updateCurrentCall({\n                        transferring: false,\n                      })\n                      eventDispatch('phone-island-call-transfer-failed', {})\n                      // Reset transfer switching\n                      // TODO - It needs to enhance how conversation connections (conv.connected) are updated server side\n                      // TODO - The transfer end is not handled when the an user hangups or after call switch\n                      dispatch.currentCall.updateTransferSwitching(false)\n                    }\n                  }\n                  if (conv?.counterpartName === 'REC') {\n                    dispatch.physicalRecorder.setRecordingTempVariable(true)\n                  }\n                }\n                // Handle outgoing call\n                if (conv && !conv.connected && conv.direction === 'out') {\n                  // Update the current outgoing conversation\n                  dispatch.currentCall.checkOutgoingUpdate({\n                    outgoingSocket: true,\n                    outgoing: conv?.counterpartName === 'REC' ? false : true,\n                    displayName: getDisplayName(conv),\n                    number: `${conv?.counterpartNum}`,\n                    username:\n                      `${\n                        extensions &&\n                        extensions[conv?.counterpartNum] &&\n                        extensions[conv?.counterpartNum].username\n                      }` || '',\n                  })\n                }\n              }\n              break\n\n            case 'onhold':\n              // The new conversation during transferring\n              const { counterpartName, counterpartNum, startTime } = conv\n              if (\n                transferring &&\n                counterpartNum &&\n                counterpartName &&\n                counterpartName !== '<unknown>'\n              ) {\n                // Add call to transfer calls\n                dispatch.currentCall.addTransferCalls({\n                  type: 'destination',\n                  displayName: getDisplayName(conv),\n                  number: counterpartNum,\n                  startTime: `${getTimestampInSeconds()}`,\n                })\n                // Set the current call informations\n                dispatch.currentCall.updateCurrentCall({\n                  displayName: getDisplayName(conv),\n                  number: counterpartNum,\n                  startTime: `${startTime / 1000}`,\n                  conversationId: conv.id,\n                })\n                // Set the view of the island to call\n                dispatch.island.setIslandView('call')\n              }\n              break\n            case 'busy_ringing':\n              eventDispatch('phone-island-call-ringing', {})\n              break\n            default:\n              break\n          }\n        }\n      } else {\n        // Without conversation for physical phone management\n        if (res.status == 'online' && userTotallyFree()) {\n          // Stop ringing sounds\n          dispatch.player.stopAudioPlayer()\n          // Reset current call info\n          dispatch.currentCall.reset()\n          dispatch.physicalRecorder.setRecordingTempVariable(false)\n          // Reset isFromStreaming flag\n          dispatch.island.setIsFromStreaming(false)\n        }\n      }\n    }\n\n    /**\n     * Initialize socket connection and listeners\n     */\n    const initSocketConnection = () => {\n      socket.current = io('https://' + hostName, {\n        upgrade: false,\n        transports: ['websocket'],\n        reconnection: true,\n        reconnectionDelay: 2000,\n      })\n\n      // save websocket to store\n      dispatch.websocket.update({ socket: socket.current })\n\n      // Handle socket errors\n      socket.current.on('connect', () => {\n        console.debug(`Socket connected sid: ${socket.current.id}`)\n        eventDispatch('phone-island-socket-connected', {})\n      })\n      socket.current.on('disconnect', (reason) => {\n        console.debug(`Socket disconnect - reason: ${reason}`)\n        if (reason.includes('server disconnect')) {\n          eventDispatch('phone-island-server-disconnected', {})\n        } else {\n          eventDispatch('phone-island-socket-disconnected', {})\n        }\n      })\n      socket.current.io.on('error', (err) => {\n        console.debug(`Socket error: `, err)\n      })\n      socket.current.on('connect_error', (err) => {\n        console.debug(`Socket connect_error: `, err)\n      })\n      socket.current.io.on('reconnect', (attempt) => {\n        eventDispatch('phone-island-socket-reconnected', {})\n        console.debug(`Socket reconnect attemp ${attempt} (sid: ${socket.current.id})`)\n      })\n      socket.current.io.on('reconnect_attempt', (attempt) => {\n        console.debug(`Socket reconnect_attempt ${attempt}`)\n      })\n      socket.current.io.on('reconnect_error', (err) => {\n        console.debug(`Socket reconnect_error: `, err)\n      })\n      socket.current.io.on('reconnect_failed', () => {\n        console.debug(`Socket reconnect_failed`)\n      })\n\n      // Checks if socket is reachable every 5 seconds\n      connectionCheckInterval.current = setInterval(() => {\n        const start = Date.now()\n        socket.current.volatile.emit(\n          'ping',\n          withTimeout(\n            () => {\n              // Remove socket_down alert\n              dispatch.alerts.removeAlert('socket_down')\n              eventDispatch('phone-island-alert-removed', {\n                type: 'socket_down',\n              })\n              eventDispatch('phone-island-socket-disconnected-popup-close', {})\n            },\n            () => {\n              // Set socket_down alert\n              dispatch.alerts.setAlert('socket_down')\n              eventDispatch('phone-island-socket-disconnected-popup-open', {})\n              console.error('Socket is unreachable!')\n            },\n            7 * 1000, // Waits for the response 7 seconds\n          ),\n        )\n      }, 7 * 1000) // Executes a new check every 7 seconds\n\n      // Handle connection message\n      socket.current.on('connect', () => {\n        console.debug('Socket on: ' + hostName + ' is connected!')\n        socket.current.emit('login', {\n          accessKeyId: `${username}`,\n          token: authToken,\n          uaType: uaType,\n        })\n      })\n\n      // Handle authentication success message\n      socket.current.on('authe_ok', () => {\n        console.debug('Socket authentication success!')\n        eventDispatch('phone-island-socket-authorized', {})\n      })\n\n      socket.current.on('userMainPresenceUpdate', (res: MainPresenceTypes) => {\n        // Update endpoints store\n        store.dispatch.users.updateEndpointMainPresence({ ...res.mainPresence })\n        // Dispatch dispatchMainPresence Event\n        dispatchMainPresence(res)\n      })\n\n      socket.current.on('extenHangup', (res: any) => {\n        const { endpoints, username } = store.getState().currentUser\n        const { isActive, conferenceStartedFrom } = store.getState().conference\n        const { view } = store.getState().island\n\n        // Get user extensions\n        const userExtensions = endpoints?.extension || []\n\n        // Find the extension type based on callerNum\n        const connectedExtension = userExtensions.find((ext) => ext.id === res.callerNum)\n        const extensionType: any = connectedExtension?.type\n\n        // If cause is normal_clearing and extension is physical or mobile\n        // Clean phone-island visibility also after user_busy ( useful for physical devices )\n        if (\n          (res.cause === 'normal_clearing' &&\n            (extensionType === 'physical' || extensionType === 'mobile')) ||\n          res?.cause === 'user_busy' ||\n          res?.cause === 'not_defined' ||\n          res?.cause === 'call_rejected'\n        ) {\n          // Reset phone island visibility after 2 seconds to avoid glitches\n          setTimeout(() => {\n            store.dispatch.island.toggleAvoidToShow(false)\n          }, 500)\n          if (isActive && conferenceStartedFrom !== username) {\n            store.dispatch.conference.resetConference()\n          }\n        } else if (\n          res?.cause === 'normal_circuit_congestion' &&\n          isActive &&\n          conferenceStartedFrom === username\n        ) {\n          eventDispatch('phone-island-view-changed', { viewType: 'waitingConference' })\n        } else if (\n          (res.cause === 'normal_clearing' ||\n            res?.cause === 'user_busy' ||\n            res?.cause === 'not_defined' ||\n            res?.cause === 'call_rejected') &&\n          (extensionType === 'webrtc' || extensionType === 'nethlink') &&\n          isActive &&\n          conferenceStartedFrom !== username\n        ) {\n          store.dispatch.conference.resetConference()\n        }\n        // if conference owner call the call with the added user inside conference\n        if (\n          res?.cause === 'interworking' &&\n          isActive &&\n          conferenceStartedFrom === username &&\n          view !== 'waitingConference'\n        ) {\n          eventDispatch('phone-island-view-changed', { viewType: 'waitingConference' })\n        }\n      })\n\n      // Avoid to show phone island if call is connected with other extension\n      socket.current.on('extenConnected', (res: { extenConnected: string }) => {\n        // Get the current user's extensions\n\n        const { default_device, endpoints } = store.getState().currentUser\n        const userExtensions = endpoints?.extension || []\n\n        // Find the extension type\n        const connectedExtension = userExtensions.find((ext) => ext.id === res.extenConnected)\n        const extensionType: any = connectedExtension?.type\n\n        // Reset only if the extension type is not webrtc or nethlink\n        // ( avoid to not show phone island if default is physical and extensionType is physical)\n        if (\n          ((default_device?.type === 'webrtc' || default_device?.type === 'nethlink') &&\n            extensionType &&\n            (extensionType === 'mobile' || extensionType === 'physical')) ||\n          (default_device?.type === 'physical' && extensionType && extensionType !== 'physical')\n        ) {\n          // Avoid to show phone island in case of answer from physical or mobile device\n          store.dispatch.island.toggleAvoidToShow(true)\n          // Launch an event to advert the user that the call it's answered from another device\n          eventDispatch('phone-island-call-answered', { extensionType })\n        }\n      })\n\n      socket.current.on('extenUpdate', (res: ExtensionTypes) => {\n        // Update extensions and conversations in users store\n        dispatch.users.updateExtension(res)\n\n        //retrieve all extensions from store\n        const { extensions }: any = store.getState().users\n        const deviceMap: any = {}\n\n        // Create a map of extensions for each user\n        for (const key in extensions) {\n          const user: any = extensions[key].username\n          const ext: any = extensions[key].exten\n\n          if (!deviceMap[user]) {\n            deviceMap[user] = []\n          }\n\n          deviceMap[user].push(ext)\n        }\n\n        const associatedExtensions: any = deviceMap[res.username]\n\n        // Initialize conversation\n        let conv = res.conversations[Object.keys(res.conversations)[0]] || {}\n\n        // Update all extensions and send the dispatch event\n        dispatchExtensions(res)\n\n        // second step update conversation\n\n        // Check if conversation is empty\n        if (isEmpty(conv)) {\n          // Check if there is at least one conversation not empty\n          const hasNonEmptyConversation = associatedExtensions?.some((ext: any) => {\n            const extConversations = extensions[ext]?.conversations\n\n            if (!isEmpty(extConversations)) {\n              // not empty conversation found\n              return true\n            }\n\n            return false\n          })\n\n          if (!hasNonEmptyConversation) {\n            // Conversation is empty and there is no conversation for the user\n            dispatchConversations(res)\n          }\n        } else {\n          // Dispatch conversation event\n          dispatchConversations(res)\n        }\n\n        // Handle only the events of the user\n        if (res.username === username) {\n          handleCurrentUserEvents(res, conv)\n          // Update the conversations of the user\n          dispatch.currentUser.updateConversations(res)\n        }\n      })\n\n      // `queueUpdate` is the socket event when the data of a queue updates\n      socket.current.on('queueUpdate', (res: QueuesUpdateTypes) => {\n        // Dispatch queueUpdate event\n        dispatchQueueUpdate(res)\n      })\n\n      // `queueMemberUpdate` is the socket event when the data of a queue member changes\n      socket.current.on('queueMemberUpdate', (res: QueueUpdateMemberTypes) => {\n        // Dispatch queueMemberUpdate event\n        dispatchQueueMemberUpdate(res)\n      })\n\n      // `takeOver` is the socket event when the user does login from another new window\n      socket.current.on('takeOver', () => {\n        // Dispatch takeOver event\n        dispatchAlreadyLogin()\n      })\n\n      // `serverReload` is the socket event when server is reloaded\n      socket.current.on('serverReloaded', () => {\n        // Dispatch serverReload event\n        dispatchServerReload()\n      })\n\n      // `serverReload` is the socket event when server is reloaded\n      socket.current.on('parkingUpdate', () => {\n        // Dispatch serverReload event\n        dispatchParkingUpdate()\n      })\n\n      // `actionNethLink` is the socket event when user make a call or a action from NethLink and has a physical device\n      socket.current.on('actionNethLink', (link, urlType) => {\n        // Dispatch phone island physical call event with the link and the urlType\n        dispatchUrlCall(link, urlType)\n      })\n\n      socket.current.on('message', (data: any) => {\n        switch (data.message) {\n          case 'screenSharingStart':\n            dispatch.island.toggleSideViewVisible(false)\n            dispatch.island.setIslandView('video')\n\n            dispatch.screenShare.update({\n              isJoiningScreenShare: true,\n              room: (data as ScreenSharingMessage).roomId,\n            })\n            break\n          case 'screenSharingStop':\n            dispatch.island.toggleSideViewVisible(false)\n            dispatch.island.setIslandView('video')\n\n            dispatch.screenShare.update({\n              isLeavingScreenShare: true,\n            })\n            break\n          default:\n            console.warn('Socket: unknown message type ', data.message)\n        }\n      })\n\n      // `updateDefaultDevice` is the socket event when user change the default device\n      socket.current.on('updateDefaultDevice', (extension: string) => {\n        // Dispatch phone island physical call event with the link and the urlType\n        dispatchDefaultDeviceUpdate(extension)\n        // Update the internal store\n        const { extensions } = store.getState().users\n        const { endpoints } = store.getState().currentUser\n        if (!extensions || !endpoints) return\n\n        const extensionInformations: any = Object.values(extensions).filter(\n          (ext) => ext?.exten === extension,\n        )\n        if (extensionInformations.length === 0) return\n\n        let objectComplete = extensionInformations[0]\n        const endpointExtension = endpoints.extension.find(\n          (endpoint) => endpoint.id === objectComplete.exten,\n        )\n        if (endpointExtension) {\n          objectComplete = { ...objectComplete, type: endpointExtension.type }\n        }\n\n        store.dispatch.currentUser.updateCurrentDefaultDevice(objectComplete)\n        //make sure to check the media permissions\n        checkMediaPermissions()\n      })\n\n      socket.current.on('confBridgeUpdate', (res: any) => {\n        if (res && res?.users) {\n          // Get User informations\n          const conferenceId = res?.id\n          const conferenceUsers = res?.users\n\n          // Get current users list to preserve mute status\n          const { usersList } = store.getState().conference\n\n          // Create a copy of the new conference users while preserving mute status\n          const updatedConferenceUsers = { ...conferenceUsers }\n\n          // Preserve mute status for existing users\n          if (usersList) {\n            Object.keys(updatedConferenceUsers).forEach((userId) => {\n              if (usersList[userId]) {\n                // Keep the existing mute status instead of using the server's value\n                updatedConferenceUsers[userId] = {\n                  ...updatedConferenceUsers[userId],\n                  muted: usersList[userId].muted,\n                }\n              }\n            })\n          }\n\n          store.dispatch.conference.updateConferenceUsersList(updatedConferenceUsers)\n          store.dispatch.conference.updateConferenceId(conferenceId)\n        }\n      })\n\n      socket.current.on('confBridgeEnd', (res: any) => {\n        if (res && res?.id) {\n          // Reset the conference store when conference ends\n          store.dispatch.conference.resetConference()\n          eventDispatch('phone-island-conference-finished', {})\n        }\n      })\n\n      socket.current.on('callWebrtc', (res: any) => {\n        // On call event from socket dispatch the call start event\n        eventDispatch('phone-island-call-start', { number: res })\n      })\n\n      socket.current.on('newVoiceMessageCounter', (res: any) => {\n        eventDispatch('phone-island-voicemail-received', { voicemailInfo: res })\n      })\n\n      socket.current.on('streamingSourceUpdate', (res: any) => {\n        eventDispatch('phone-island-streaming-information-received', { res })\n        const streamingData = res.streaming || (res.res && res.res.streaming)\n\n        if (streamingData) {\n          const { source, image } = streamingData\n          if (source && image) {\n            const { isFromStreaming } = store.getState().island\n            const { streamingSourceNumber } = store.getState().currentCall\n            const sourceId = getStreamingSourceId(streamingSourceNumber)\n\n            dispatch.streaming.updateSourceImage({\n              source: source,\n              image: image,\n            })\n          }\n        }\n      })\n    }\n\n    initSocketConnection()\n\n    // Stop the check socket interval\n    // Close the socket connection\n    return () => {\n      clearInterval(connectionCheckInterval.current)\n      socket.current.close()\n    }\n  }, [hostName, username, authToken, uaType, dispatch])\n\n  // Manage reload events\n  useEffect(() => {\n    if (reload) {\n      console.info('websocket reconnection')\n      socket.current.disconnect()\n      socket.current.connect()\n      reloadedCallback()\n    }\n  }, [reload])\n\n  return <>{children}</>\n}\n"],"names":["_a","hostName","username","authToken","reload","reloadedCallback","children","uaType","dispatch","useDispatch","connectionCheckInterval","useRef","socket","isUpdatingUserInfo","useSelector","state","currentUser","useEffect","handleStreamingSource","conv","counterpartNum","isFromStreaming","island","setIsFromStreaming","currentCall","updateCurrentCall","streamingSourceNumber","sourceId","getStreamingSourceId","subscribe","id","catch","error","console","handleCurrentUserEvents","res","store","getState","transferring","transferSwitching","transferCalls","view","Object","keys","length","status","extensions_1","users","extensions","default_device","_b","endpoints_1","endpoints","username_1","_c","incoming","hasOnlineNethlink","userExtensions","values","filter","ext","some","endpointExtension","extension","find","endpoint","exten","type","undefined","current","getCurrentUserInfo","then","userInfo","updateCurrentUser","settings","open_param_url","paramUrl","setOpenParamUrlType","finally","setTimeout","checkIncomingUpdatePlay","conversationId","displayName","getDisplayName","number","concat","incomingSocket","ownerExtension","owner","chDest","chSource","direction","inConference","linkedId","uniqueId","throughQueue","throughTrunk","recording","setIslandView","eventDispatch","openParamUrlType","urlOpened","calculatedThroughTrunk","isFromTrunk","setThroughTrunk","setUrlOpened","counterpartName","connected","checkAcceptedUpdate","acceptedSocket","addTransferCalls","startTime","getTimestampInSeconds","isPhysical","accepted","player","stopAudioPlayer","setAudioPlayerLoop","checkDefaultDeviceConversationActive","deleteTransferCalls","inTransferCalls","item","updateTransferSwitching","physicalRecorder","setRecordingTempVariable","checkOutgoingUpdate","outgoingSocket","outgoing","userTotallyFree","reset","io","upgrade","transports","reconnection","reconnectionDelay","websocket","update","on","debug","reason","includes","err","attempt","setInterval","volatile","emit","withTimeout","alerts","removeAlert","setAlert","accessKeyId","token","updateEndpointMainPresence","__assign","mainPresence","dispatchMainPresence","conference","isActive","conferenceStartedFrom","connectedExtension","callerNum","extensionType","cause","toggleAvoidToShow","resetConference","viewType","extenConnected","updateExtension","deviceMap","key","user","push","associatedExtensions","conversations","dispatchExtensions","isEmpty","hasNonEmptyConversation","extConversations","dispatchConversations","updateConversations","dispatchQueueUpdate","dispatchQueueMemberUpdate","dispatchAlreadyLogin","dispatchServerReload","dispatchParkingUpdate","link","urlType","dispatchUrlCall","data","message","toggleSideViewVisible","screenShare","isJoiningScreenShare","room","roomId","isLeavingScreenShare","warn","dispatchDefaultDeviceUpdate","extensionInformations","objectComplete","updateCurrentDefaultDevice","checkMediaPermissions","conferenceId","conferenceUsers","usersList_1","usersList","updatedConferenceUsers_1","forEach","userId","muted","updateConferenceUsersList","updateConferenceId","voicemailInfo","streamingData","streaming","source","image","updateSourceImage","clearInterval","close","info","disconnect","connect","React","createElement","Fragment"],"mappings":"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"}