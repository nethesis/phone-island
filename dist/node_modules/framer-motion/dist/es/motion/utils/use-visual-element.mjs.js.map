{"version":3,"file":"use-visual-element.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs"],"sourcesContent":["import { microtask } from 'motion-dom';\nimport { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\n        !window.MotionHandoffIsComplete?.(optimisedAppearId) &&\n        window.MotionHasOptimisedAnimation?.(optimisedAppearId));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                window.MotionHandoffMarkAsComplete?.(optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        crossfade: layoutCrossfade,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\nexport { useVisualElement };\n"],"names":["getClosestProjectingNode","visualElement","options","allowProjection","projection","parent","Component","visualState","props","createVisualElement","ProjectionNodeConstructor","useContext","MotionContext","lazyContext","LazyContext","presenceContext","PresenceContext","reducedMotionConfig","MotionConfigContext","reducedMotion","visualElementRef","useRef","renderer","current","blockInitialAnimation","initial","initialLayoutGroupConfig","SwitchLayoutGroupContext","type","initialPromotionConfig","layoutId","layout","drag","dragConstraints","layoutScroll","layoutRoot","layoutCrossfade","latestValues","undefined","setOptions","alwaysMeasureLayout","Boolean","isRefObject","animationType","crossfade","createProjectionNode","isMounted","useInsertionEffect","update","optimisedAppearId","optimizedAppearDataAttribute","wantsHandoff","window","MotionHandoffIsComplete","MotionHasOptimisedAnimation","useIsomorphicLayoutEffect","MotionIsMounted","updateFeatures","microtask","render","animationState","animateChanges","useEffect","queueMicrotask","MotionHandoffMarkAsComplete"],"mappings":"6kBA4HA,SAASA,EAAyBC,GAC9B,GAAKA,EAEL,OAAiD,IAA1CA,EAAcC,QAAQC,gBACvBF,EAAcG,WACdJ,EAAyBC,EAAcI,OACjD,0BAvHA,SAA0BC,EAAWC,EAAaC,EAAOC,EAAqBC,GAC1E,MAAQT,cAAeI,GAAWM,EAAAA,WAAWC,EAAAA,eACvCC,EAAcF,aAAWG,EAAAA,aACzBC,EAAkBJ,aAAWK,EAAAA,iBAC7BC,EAAsBN,EAAAA,WAAWO,EAAmBA,qBAAEC,cACtDC,EAAmBC,SAAO,MAIhCZ,EAAsBA,GAAuBI,EAAYS,UACpDF,EAAiBG,SAAWd,IAC7BW,EAAiBG,QAAUd,EAAoBH,EAAW,CACtDC,cACAF,SACAG,QACAO,kBACAS,wBAAuBT,IACW,IAA5BA,EAAgBU,QAEtBR,yBAGR,MAAMhB,EAAgBmB,EAAiBG,QAKjCG,EAA2Bf,aAAWgB,EAAAA,2BACxC1B,GACCA,EAAcG,aACfM,GACwB,SAAvBT,EAAc2B,MAA0C,QAAvB3B,EAAc2B,MA0DxD,SAA8B3B,EAAeO,EAAOE,EAA2BmB,GAC3E,MAAMC,SAAEA,EAAQC,OAAEA,EAAMC,KAAEA,EAAIC,gBAAEA,EAAeC,aAAEA,EAAYC,WAAEA,EAAUC,gBAAEA,GAAqB5B,EAChGP,EAAcG,WAAa,IAAIM,EAA0BT,EAAcoC,aAAc7B,EAAM,8BACrF8B,EACAtC,EAAyBC,EAAcI,SAC7CJ,EAAcG,WAAWmC,WAAW,CAChCT,WACAC,SACAS,oBAAqBC,QAAQT,IAAUC,GAAmBS,EAAAA,YAAYT,GACtEhC,gBAQA0C,cAAiC,iBAAXZ,EAAsBA,EAAS,OACrDF,yBACAe,UAAWR,EACXF,eACAC,cAER,CAhFQU,CAAqBzB,EAAiBG,QAASf,EAAOE,EAA2BgB,GAErF,MAAMoB,EAAYzB,UAAO,GACzB0B,EAAAA,oBAAmB,KAKX9C,GAAiB6C,EAAUvB,SAC3BtB,EAAc+C,OAAOxC,EAAOO,EAChC,IAMJ,MAAMkC,EAAoBzC,EAAM0C,EAAAA,8BAC1BC,EAAe9B,EAAMA,OAACoB,QAAQQ,KAC/BG,OAAOC,0BAA0BJ,IAClCG,OAAOE,8BAA8BL,IAoCzC,OAnCAM,EAAAA,2BAA0B,KACjBtD,IAEL6C,EAAUvB,SAAU,EACpB6B,OAAOI,iBAAkB,EACzBvD,EAAcwD,iBACdC,EAAAA,UAAUC,OAAO1D,EAAc0D,QAW3BR,EAAa5B,SAAWtB,EAAc2D,gBACtC3D,EAAc2D,eAAeC,iBACjC,IAEJC,EAAAA,WAAU,KACD7D,KAEAkD,EAAa5B,SAAWtB,EAAc2D,gBACvC3D,EAAc2D,eAAeC,iBAE7BV,EAAa5B,UAEbwC,gBAAe,KACXX,OAAOY,8BAA8Bf,EAAkB,IAE3DE,EAAa5B,SAAU,GAC3B,IAEGtB,CACX"}