"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("../Feature.mjs.js"),t=require("./observers.mjs.js");const r={some:0,all:1};class s extends e.Feature{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:s,margin:n,amount:o="some",once:i}=e,u={root:s?s.current:void 0,rootMargin:n,threshold:"number"==typeof o?o:r[o]};return t.observeIntersection(this.node.current,u,(e=>{const{isIntersecting:t}=e;if(this.isInView===t)return;if(this.isInView=t,i&&!t&&this.hasEnteredView)return;t&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",t);const{onViewportEnter:r,onViewportLeave:s}=this.node.getProps(),n=t?r:s;n&&n(e)}))}mount(){this.startObserver()}update(){if("undefined"==typeof IntersectionObserver)return;const{props:e,prevProps:t}=this.node;["amount","margin","root"].some(function({viewport:e={}},{viewport:t={}}={}){return r=>e[r]!==t[r]}(e,t))&&this.startObserver()}unmount(){}}exports.InViewFeature=s;
//# sourceMappingURL=index.mjs.js.map
