{"version":3,"file":"observers.mjs.js","sources":["../../../../../../../../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"sourcesContent":["/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n"],"names":["observerCallbacks","WeakMap","observers","fireObserverCallback","entry","callback","get","target","fireAllObserverCallbacks","entries","forEach","element","options","rootInteresectionObserver","root","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","initIntersectionObserver","observe","delete","unobserve"],"mappings":"oEAKA,MAAMA,EAAoB,IAAIC,QAMxBC,EAAY,IAAID,QAChBE,EAAwBC,IAC1B,MAAMC,EAAWL,EAAkBM,IAAIF,EAAMG,QAC7CF,GAAYA,EAASD,EAAM,EAEzBI,EAA4BC,IAC9BA,EAAQC,QAAQP,EAAqB,8BAqBzC,SAA6BQ,EAASC,EAASP,GAC3C,MAAMQ,EApBV,UAAkCC,KAAEA,KAASF,IACzC,MAAMG,EAAaD,GAAQE,SAItBd,EAAUe,IAAIF,IACfb,EAAUgB,IAAIH,EAAY,CAAA,GAE9B,MAAMI,EAAgBjB,EAAUI,IAAIS,GAC9BK,EAAMC,KAAKC,UAAUV,GAQ3B,OAHKO,EAAcC,KACfD,EAAcC,GAAO,IAAIG,qBAAqBf,EAA0B,CAAEM,UAASF,KAEhFO,EAAcC,EACzB,CAEsCI,CAAyBZ,GAG3D,OAFAZ,EAAkBkB,IAAIP,EAASN,GAC/BQ,EAA0BY,QAAQd,GAC3B,KACHX,EAAkB0B,OAAOf,GACzBE,EAA0Bc,UAAUhB,EAAQ,CAEpD"}