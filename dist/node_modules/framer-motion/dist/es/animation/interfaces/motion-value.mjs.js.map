{"version":3,"file":"motion-value.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { getValueTransition, frame, AsyncMotionValueAnimation } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        Object.assign(options, getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n    /**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (MotionGlobalConfig.instantAnimations ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            return;\n        }\n    }\n    return new AsyncMotionValueAnimation(options);\n};\n\nexport { animateMotionValue };\n"],"names":["animateMotionValue","name","value","target","transition","element","isHandoff","onComplete","valueTransition","getValueTransition","delay","elapsed","secondsToMilliseconds","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","undefined","isTransitionDefined","Object","assign","getDefaultTransition","duration","repeatDelay","from","shouldSkip","type","MotionGlobalConfig","instantAnimations","skipAnimations","allowFlatten","get","finalKeyframe","getFinalKeyframe","frame","update","AsyncMotionValueAnimation"],"mappings":"gpBAM2BA,CAACC,EAAMC,EAAOC,EAAQC,EAAa,GAAIC,EAASC,IAAeC,IACtF,MAAMC,EAAkBC,EAAkBA,mBAACL,EAAYH,IAAS,CAAA,EAM1DS,EAAQF,EAAgBE,OAASN,EAAWM,OAAS,EAK3D,IAAIC,QAAEA,EAAU,GAAMP,EACtBO,GAAoBC,wBAAsBF,GAC1C,MAAMG,EAAU,CACZC,UAAWC,MAAMC,QAAQb,GAAUA,EAAS,CAAC,KAAMA,GACnDc,KAAM,UACNC,SAAUhB,EAAMiB,iBACbX,EACHE,OAAQC,EACRS,SAAWC,IACPnB,EAAMoB,IAAID,GACVb,EAAgBY,UAAYZ,EAAgBY,SAASC,EAAE,EAE3Dd,WAAYA,KACRA,IACAC,EAAgBD,YAAcC,EAAgBD,YAAY,EAE9DN,OACAsB,YAAarB,EACbG,QAASC,OAAYkB,EAAYnB,GAMhCoB,EAAAA,oBAAoBjB,IACrBkB,OAAOC,OAAOd,EAASe,EAAoBA,qBAAC3B,EAAMY,IAOtDA,EAAQgB,WAAahB,EAAQgB,SAAWjB,EAAAA,sBAAsBC,EAAQgB,WACtEhB,EAAQiB,cAAgBjB,EAAQiB,YAAclB,EAAAA,sBAAsBC,EAAQiB,mBAIvDN,IAAjBX,EAAQkB,OACRlB,EAAQC,UAAU,GAAKD,EAAQkB,MAEnC,IAAIC,GAAa,EAwBjB,KAvBqB,IAAjBnB,EAAQoB,MACc,IAArBpB,EAAQgB,WAAmBhB,EAAQiB,eACpCjB,EAAQgB,SAAW,EACG,IAAlBhB,EAAQH,QACRsB,GAAa,KAGjBE,qBAAmBC,mBACnBD,EAAkBA,mBAACE,kBACnBJ,GAAa,EACbnB,EAAQgB,SAAW,EACnBhB,EAAQH,MAAQ,GAMpBG,EAAQwB,cAAgB7B,EAAgByB,OAASzB,EAAgBS,KAM7De,IAAe1B,QAA6BkB,IAAhBtB,EAAMoC,MAAqB,CACvD,MAAMC,EAAgBC,EAAgBA,iBAAC3B,EAAQC,UAAWN,GAC1D,QAAsBgB,IAAlBe,EAKA,YAJAE,EAAKA,MAACC,QAAO,KACT7B,EAAQO,SAASmB,GACjB1B,EAAQN,YAAY,GAIhC,CACA,OAAO,IAAIoC,EAAAA,0BAA0B9B,EAAQ"}