{"version":3,"file":"VisualElementDragControls.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs"],"sourcesContent":["import { frame, mixNumber, setDragLock, percent } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { animateMotionValue } from '../../animation/interfaces/motion-value.mjs';\nimport { addDomEvent } from '../../events/add-dom-event.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { convertBoxToBoundingBox, convertBoundingBoxToBox } from '../../projection/geometry/conversion.mjs';\nimport { calcLength } from '../../projection/geometry/delta-calc.mjs';\nimport { createBox } from '../../projection/geometry/models.mjs';\nimport { eachAxis } from '../../projection/utils/each-axis.mjs';\nimport { measurePageBox } from '../../projection/utils/measure.mjs';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { PanSession } from '../pan/PanSession.mjs';\nimport { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';\n\nconst elementDragControls = new WeakMap();\n/**\n *\n */\n// let latestPointerEvent: PointerEvent\nclass VisualElementDragControls {\n    constructor(visualElement) {\n        this.openDragLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = { x: 0, y: 0 };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */\n        this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */\n        this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    start(originEvent, { snapToCursor = false } = {}) {\n        /**\n         * Don't start dragging if this component is exiting\n         */\n        const { presenceContext } = this.visualElement;\n        if (presenceContext && presenceContext.isPresent === false)\n            return;\n        const onSessionStart = (event) => {\n            const { dragSnapToOrigin } = this.getProps();\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\n            if (snapToCursor) {\n                this.snapToCursor(extractEventInfo(event).point);\n            }\n        };\n        const onStart = (event, info) => {\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps();\n            if (drag && !dragPropagation) {\n                if (this.openDragLock)\n                    this.openDragLock();\n                this.openDragLock = setDragLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!this.openDragLock)\n                    return;\n            }\n            this.isDragging = true;\n            this.currentDirection = null;\n            this.resolveConstraints();\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true;\n                this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */\n            eachAxis((axis) => {\n                let current = this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    const { projection } = this.visualElement;\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis];\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis);\n                            current = length * (parseFloat(current) / 100);\n                        }\n                    }\n                }\n                this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame.postRender(() => onDragStart(event, info));\n            }\n            addValueToWillChange(this.visualElement, \"transform\");\n            const { animationState } = this.visualElement;\n            animationState && animationState.setActive(\"whileDrag\", true);\n        };\n        const onMove = (event, info) => {\n            // latestPointerEvent = event\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock)\n                return;\n            const { offset } = info;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            this.updateAxis(\"x\", info.point, offset);\n            this.updateAxis(\"y\", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */\n            this.visualElement.render();\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag && onDrag(event, info);\n        };\n        const onSessionEnd = (event, info) => this.stop(event, info);\n        const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === \"paused\" &&\n            this.getAxisMotionValue(axis).animation?.play());\n        const { dragSnapToOrigin } = this.getProps();\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart,\n            onStart,\n            onMove,\n            onSessionEnd,\n            resumeAnimation,\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\n            dragSnapToOrigin,\n            contextWindow: getContextWindow(this.visualElement),\n        });\n    }\n    stop(event, info) {\n        const isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging)\n            return;\n        const { velocity } = info;\n        this.startAnimation(velocity);\n        const { onDragEnd } = this.getProps();\n        if (onDragEnd) {\n            frame.postRender(() => onDragEnd(event, info));\n        }\n    }\n    cancel() {\n        this.isDragging = false;\n        const { projection, animationState } = this.visualElement;\n        if (projection) {\n            projection.isAnimationBlocked = false;\n        }\n        this.panSession && this.panSession.end();\n        this.panSession = undefined;\n        const { dragPropagation } = this.getProps();\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock();\n            this.openDragLock = null;\n        }\n        animationState && animationState.setActive(\"whileDrag\", false);\n    }\n    updateAxis(axis, _point, offset) {\n        const { drag } = this.getProps();\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\n            return;\n        const axisValue = this.getAxisMotionValue(axis);\n        let next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    }\n    resolveConstraints() {\n        const { dragConstraints, dragElastic } = this.getProps();\n        const layout = this.visualElement.projection &&\n            !this.visualElement.projection.layout\n            ? this.visualElement.projection.measure(false)\n            : this.visualElement.projection?.layout;\n        const prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        }\n        else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n            }\n            else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints) {\n            eachAxis((axis) => {\n                if (this.constraints !== false &&\n                    this.getAxisMotionValue(axis)) {\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n                }\n            });\n        }\n    }\n    resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n        if (!constraints || !isRefObject(constraints))\n            return false;\n        const constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        const { projection } = this.visualElement;\n        // TODO\n        if (!projection || !projection.layout)\n            return false;\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    }\n    startAnimation(velocity) {\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\n        const constraints = this.constraints || {};\n        const momentumAnimations = eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return;\n            }\n            let transition = (constraints && constraints[axis]) || {};\n            if (dragSnapToOrigin)\n                transition = { min: 0, max: 0 };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            const bounceStiffness = dragElastic ? 200 : 1000000;\n            const bounceDamping = dragElastic ? 40 : 10000000;\n            const inertia = {\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition,\n            };\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    }\n    startAxisValueAnimation(axis, transition) {\n        const axisValue = this.getAxisMotionValue(axis);\n        addValueToWillChange(this.visualElement, axis);\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n    }\n    stopAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n    }\n    pauseAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());\n    }\n    getAnimationState(axis) {\n        return this.getAxisMotionValue(axis).animation?.state;\n    }\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    getAxisMotionValue(axis) {\n        const dragKey = `_drag${axis.toUpperCase()}`;\n        const props = this.visualElement.getProps();\n        const externalMotionValue = props[dragKey];\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(axis, (props.initial\n                ? props.initial[axis]\n                : undefined) || 0);\n    }\n    snapToCursor(point) {\n        eachAxis((axis) => {\n            const { drag } = this.getProps();\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection))\n                return;\n            const { projection } = this.visualElement;\n            const axisValue = this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis];\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5));\n            }\n        });\n    }\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    scalePositionWithinConstraints() {\n        if (!this.visualElement.current)\n            return;\n        const { drag, dragConstraints } = this.getProps();\n        const { projection } = this.visualElement;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        const boxProgress = { x: 0, y: 0 };\n        eachAxis((axis) => {\n            const axisValue = this.getAxisMotionValue(axis);\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        const { transformTemplate } = this.visualElement.getProps();\n        this.visualElement.current.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        projection.root && projection.root.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            const axisValue = this.getAxisMotionValue(axis);\n            const { min, max } = this.constraints[axis];\n            axisValue.set(mixNumber(min, max, boxProgress[axis]));\n        });\n    }\n    addListeners() {\n        if (!this.visualElement.current)\n            return;\n        elementDragControls.set(this.visualElement, this);\n        const element = this.visualElement.current;\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n            const { drag, dragListener = true } = this.getProps();\n            drag && dragListener && this.start(event);\n        });\n        const measureDragConstraints = () => {\n            const { dragConstraints } = this.getProps();\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        };\n        const { projection } = this.visualElement;\n        const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        if (projection && !projection.layout) {\n            projection.root && projection.root.updateScroll();\n            projection.updateLayout();\n        }\n        frame.read(measureDragConstraints);\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */\n        const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", (({ delta, hasLayoutChanged }) => {\n            if (this.isDragging && hasLayoutChanged) {\n                eachAxis((axis) => {\n                    const motionValue = this.getAxisMotionValue(axis);\n                    if (!motionValue)\n                        return;\n                    this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                this.visualElement.render();\n            }\n        }));\n        return () => {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\n        };\n    }\n    getProps() {\n        const props = this.visualElement.getProps();\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum,\n        };\n    }\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n    let direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\nexport { VisualElementDragControls, elementDragControls };\n"],"names":["elementDragControls","WeakMap","shouldDrag","direction","drag","currentDirection","constructor","visualElement","this","openDragLock","isDragging","originPoint","x","y","constraints","hasMutatedConstraints","elastic","createBox","start","originEvent","snapToCursor","presenceContext","isPresent","dragSnapToOrigin","getProps","panSession","PanSession","onSessionStart","event","pauseAnimation","stopAnimation","extractEventInfo","point","onStart","info","dragPropagation","onDragStart","setDragLock","resolveConstraints","projection","isAnimationBlocked","target","undefined","eachAxis","axis","current","getAxisMotionValue","get","percent","test","layout","measuredAxis","layoutBox","calcLength","parseFloat","frame","postRender","addValueToWillChange","animationState","setActive","onMove","dragDirectionLock","onDirectionLock","onDrag","offset","lockThreshold","Math","abs","getCurrentDirection","updateAxis","render","onSessionEnd","stop","resumeAnimation","getAnimationState","animation","play","transformPagePoint","getTransformPagePoint","contextWindow","getContextWindow","cancel","velocity","startAnimation","onDragEnd","end","_point","axisValue","next","applyConstraints","set","dragConstraints","dragElastic","measure","prevConstraints","isRefObject","resolveRefConstraints","calcRelativeConstraints","resolveDragElastic","rebaseAxisConstraints","onMeasureDragConstraints","constraintsElement","invariant","constraintsBox","measurePageBox","root","measuredConstraints","calcViewportConstraints","userConstraints","convertBoxToBoundingBox","convertBoundingBoxToBox","dragMomentum","dragTransition","onDragTransitionEnd","momentumAnimations","transition","min","max","bounceStiffness","bounceDamping","inertia","type","timeConstant","restDelta","restSpeed","startAxisValueAnimation","Promise","all","then","animateMotionValue","pause","state","dragKey","toUpperCase","props","externalMotionValue","getValue","initial","mixNumber","scalePositionWithinConstraints","boxProgress","latest","calcOrigin","transformTemplate","style","transform","updateScroll","updateLayout","addListeners","element","stopPointerListener","addPointerEvent","dragListener","measureDragConstraints","stopMeasureLayoutListener","addEventListener","read","stopResizeListener","addDomEvent","window","stopLayoutUpdateListener","delta","hasLayoutChanged","motionValue","translate","defaultElastic"],"mappings":"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"}