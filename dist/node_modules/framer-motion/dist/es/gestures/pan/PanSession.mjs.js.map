{"version":3,"file":"PanSession.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs"],"sourcesContent":["import { frame, isPrimaryPointer, cancelFrame, frameData } from 'motion-dom';\nimport { pipe, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"names":["transformPoint","info","transformPagePoint","point","subtractPoint","a","b","x","y","getPanInfo","history","delta","lastDevicePoint","offset","startDevicePoint","velocity","getVelocity","length","timeDelta","i","timestampedPoint","lastPoint","timestamp","secondsToMilliseconds","time","millisecondsToSeconds","currentVelocity","Infinity","constructor","event","handlers","contextWindow","dragSnapToOrigin","this","startEvent","lastMoveEvent","lastMoveEventInfo","window","updatePoint","isPanStarted","isDistancePastThreshold","distance2D","frameData","push","onStart","onMove","handlePointerMove","frame","update","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","isPrimaryPointer","initialInfo","extractEventInfo","onSessionStart","removeListeners","pipe","addPointerEvent","updateHandlers","cancelFrame"],"mappings":"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"}