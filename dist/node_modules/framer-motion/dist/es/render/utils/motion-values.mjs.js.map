{"version":3,"file":"motion-values.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs"],"sourcesContent":["import { motionValue } from 'motion-dom';\nimport { warnOnce } from 'motion-utils';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */\n            if (process.env.NODE_ENV === \"development\") {\n                warnOnce(nextValue.version === \"12.9.2\", `Attempting to mix Motion versions ${nextValue.version} with 12.9.2 may not work as expected.`);\n            }\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue);\n                }\n                else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue);\n                }\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nexport { updateMotionValuesFromProps };\n"],"names":["element","next","prev","key","nextValue","prevValue","isMotionValue","addValue","process","env","NODE_ENV","warnOnce","version","motionValue","owner","hasValue","existingValue","getValue","liveStyle","jump","hasAnimated","set","latestValue","getStaticValue","undefined","removeValue"],"mappings":"sSAIA,SAAqCA,EAASC,EAAMC,GAChD,IAAK,MAAMC,KAAOF,EAAM,CACpB,MAAMG,EAAYH,EAAKE,GACjBE,EAAYH,EAAKC,GACvB,GAAIG,EAAAA,cAAcF,GAKdJ,EAAQO,SAASJ,EAAKC,GAKO,gBAAzBI,QAAQC,IAAIC,UACZC,WAA+B,WAAtBP,EAAUQ,QAAsB,qCAAqCR,EAAUQ,sDAG3F,GAAIN,EAAAA,cAAcD,GAKnBL,EAAQO,SAASJ,EAAKU,EAAAA,YAAYT,EAAW,CAAEU,MAAOd,UAErD,GAAIK,IAAcD,EAMnB,GAAIJ,EAAQe,SAASZ,GAAM,CACvB,MAAMa,EAAgBhB,EAAQiB,SAASd,IACP,IAA5Ba,EAAcE,UACdF,EAAcG,KAAKf,GAEbY,EAAcI,aACpBJ,EAAcK,IAAIjB,EAE1B,KACK,CACD,MAAMkB,EAActB,EAAQuB,eAAepB,GAC3CH,EAAQO,SAASJ,EAAKU,EAAAA,iBAA4BW,IAAhBF,EAA4BA,EAAclB,EAAW,CAAEU,MAAOd,IACpG,CAER,CAEA,IAAK,MAAMG,KAAOD,OACIsB,IAAdvB,EAAKE,IACLH,EAAQyB,YAAYtB,GAE5B,OAAOF,CACX"}