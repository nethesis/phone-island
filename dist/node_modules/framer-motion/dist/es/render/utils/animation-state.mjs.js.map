{"version":3,"file":"animation-state.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"sourcesContent":["import { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? visualElement.presenceContext?.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            /**\n             * If the initial prop contains a transition we can use that, otherwise\n             * allow the animation function to use the visual element's default.\n             */\n            if (typeof props.initial !== \"boolean\") {\n                const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)\n                    ? props.initial[0]\n                    : props.initial);\n                if (initialTransition && initialTransition.transition) {\n                    fallbackAnimation.transition = initialTransition.transition;\n                }\n            }\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget ?? null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState };\n"],"names":["reversePriorityOrder","variantPriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","animation","options","animateVisualElement","checkVariantsDidChange","prev","next","Array","isArray","shallowCompare","createTypeState","isActive","protectedKeys","needsAnimating","prevResolvedValues","createState","animate","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit","state","isInitialRender","buildResolvedTypeValues","type","acc","definition","resolved","resolveVariant","presenceContext","custom","undefined","transition","transitionEnd","target","animateChanges","changedActiveType","props","context","getVariantContext","parent","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","typeState","prop","propIsVariant","isVariantLabel","activeDelta","isInherited","manuallyAnimateOnMount","prevProp","isAnimationControls","variantDidChange","shouldAnimateType","handledRemovedValues","definitionList","resolvedValues","reduce","allKeys","markToAnimate","key","has","delete","motionValue","getValue","liveStyle","hasOwnProperty","valueHasChanged","isKeyframesTarget","add","blockInitialAnimation","push","size","fallbackAnimation","initial","initialTransition","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","resolve","setActive","variantChildren","child","animationState","setAnimateFunction","makeAnimator","getState","reset"],"mappings":"wdASA,MAAMA,EAAuB,IAAIC,wBAAsBC,UACjDC,EAAoBF,EAAoBA,qBAACG,OAC/C,SAASC,EAAYC,GACjB,OAAQC,GAAeC,QAAQC,IAAIF,EAAWG,KAAI,EAAGC,YAAWC,aAAcC,EAAoBA,qBAACP,EAAeK,EAAWC,KACjI,CA2SA,SAASE,EAAuBC,EAAMC,GAClC,MAAoB,iBAATA,EACAA,IAASD,IAEXE,MAAMC,QAAQF,KACXG,EAAcA,eAACH,EAAMD,EAGrC,CACA,SAASK,EAAgBC,GAAW,GAChC,MAAO,CACHA,WACAC,cAAe,CAAE,EACjBC,eAAgB,CAAE,EAClBC,mBAAoB,CAAC,EAE7B,CACA,SAASC,IACL,MAAO,CACHC,QAASN,GAAgB,GACzBO,YAAaP,IACbQ,WAAYR,IACZS,SAAUT,IACVU,UAAWV,IACXW,WAAYX,IACZY,KAAMZ,IAEd,+DArUA,SAA8Bd,GAC1B,IAAIoB,EAAUrB,EAAYC,GACtB2B,EAAQR,IACRS,GAAkB,EAKtB,MAAMC,EAA2BC,GAAS,CAACC,EAAKC,KAC5C,MAAMC,EAAWC,EAAAA,eAAelC,EAAegC,EAAqB,SAATF,EACrD9B,EAAcmC,iBAAiBC,YAC/BC,GACN,GAAIJ,EAAU,CACV,MAAMK,WAAEA,EAAUC,cAAEA,KAAkBC,GAAWP,EACjDF,EAAM,IAAKA,KAAQS,KAAWD,EAClC,CACA,OAAOR,CAAG,EAmBd,SAASU,EAAeC,GACpB,MAAMC,MAAEA,GAAU3C,EACZ4C,EAAUC,EAAiBA,kBAAC7C,EAAc8C,SAAW,CAAA,EAKrD7C,EAAa,GAKb8C,EAAc,IAAIC,IAMxB,IAAIC,EAAkB,CAAA,EAKlBC,EAAsBC,IAO1B,IAAK,IAAIC,EAAI,EAAGA,EAAIvD,EAAmBuD,IAAK,CACxC,MAAMtB,EAAOpC,EAAqB0D,GAC5BC,EAAY1B,EAAMG,GAClBwB,OAAuBjB,IAAhBM,EAAMb,GACba,EAAMb,GACNc,EAAQd,GACRyB,EAAgBC,iBAAeF,GAK/BG,EAAc3B,IAASY,EAAoBW,EAAUtC,SAAW,MAClD,IAAhB0C,IACAP,EAAsBE,GAO1B,IAAIM,EAAcJ,IAASV,EAAQd,IAC/BwB,IAASX,EAAMb,IACfyB,EAeJ,GAXIG,GACA9B,GACA5B,EAAc2D,yBACdD,GAAc,GAMlBL,EAAUrC,cAAgB,IAAKiC,IAI7BI,EAAUtC,UAA4B,OAAhB0C,IAElBH,IAASD,EAAUO,UAErBC,EAAAA,oBAAoBP,IACJ,kBAATA,EACP,SAOJ,MAAMQ,EAAmBtD,EAAuB6C,EAAUO,SAAUN,GACpE,IAAIS,EAAoBD,GAEnBhC,IAASY,GACNW,EAAUtC,WACT2C,GACDH,GAEHH,EAAIF,GAAuBK,EAC5BS,GAAuB,EAK3B,MAAMC,EAAiBtD,MAAMC,QAAQ0C,GAAQA,EAAO,CAACA,GAKrD,IAAIY,EAAiBD,EAAeE,OAAOtC,EAAwBC,GAAO,CAAA,IACtD,IAAhB2B,IACAS,EAAiB,IAUrB,MAAMhD,mBAAEA,EAAqB,CAAC,GAAMmC,EAC9Be,EAAU,IACTlD,KACAgD,GAEDG,EAAiBC,IACnBP,GAAoB,EAChBhB,EAAYwB,IAAID,KAChBN,GAAuB,EACvBjB,EAAYyB,OAAOF,IAEvBjB,EAAUpC,eAAeqD,IAAO,EAChC,MAAMG,EAAczE,EAAc0E,SAASJ,GACvCG,IACAA,EAAYE,WAAY,EAAK,EAErC,IAAK,MAAML,KAAOF,EAAS,CACvB,MAAM1D,EAAOwD,EAAeI,GACtB7D,EAAOS,EAAmBoD,GAEhC,GAAIrB,EAAgB2B,eAAeN,GAC/B,SAIJ,IAAIO,GAAkB,EAElBA,EADAC,EAAiBA,kBAACpE,IAASoE,EAAiBA,kBAACrE,IAC1BI,EAAAA,eAAeH,EAAMD,GAGtBC,IAASD,EAE3BoE,EACInE,QAEA2D,EAAcC,GAIdvB,EAAYgC,IAAIT,QAGNjC,IAAT3B,GAAsBqC,EAAYwB,IAAID,GAK3CD,EAAcC,GAOdjB,EAAUrC,cAAcsD,IAAO,CAEvC,CAKAjB,EAAUO,SAAWN,EACrBD,EAAUnC,mBAAqBgD,EAI3Bb,EAAUtC,WACVkC,EAAkB,IAAKA,KAAoBiB,IAE3CtC,GAAmB5B,EAAcgF,wBACjCjB,GAAoB,GAQpBA,MAFyBL,GAAeI,IACIE,IAE5C/D,EAAWgF,QAAQhB,EAAe7D,KAAKC,IAAe,CAClDA,UAAWA,EACXC,QAAS,CAAEwB,YAGvB,CAMA,GAAIiB,EAAYmC,KAAM,CAClB,MAAMC,EAAoB,CAAA,EAK1B,GAA6B,kBAAlBxC,EAAMyC,QAAuB,CACpC,MAAMC,EAAoBnD,EAAcA,eAAClC,EAAeW,MAAMC,QAAQ+B,EAAMyC,SACtEzC,EAAMyC,QAAQ,GACdzC,EAAMyC,SACRC,GAAqBA,EAAkB/C,aACvC6C,EAAkB7C,WAAa+C,EAAkB/C,WAEzD,CACAS,EAAYuC,SAAShB,IACjB,MAAMiB,EAAiBvF,EAAcwF,cAAclB,GAC7CG,EAAczE,EAAc0E,SAASJ,GACvCG,IACAA,EAAYE,WAAY,GAE5BQ,EAAkBb,GAAOiB,GAAkB,IAAI,IAEnDtF,EAAWgF,KAAK,CAAE5E,UAAW8E,GACjC,CACA,IAAIM,EAAgBC,QAAQzF,EAAWH,QAOvC,OANI8B,IACmB,IAAlBe,EAAMyC,SAAqBzC,EAAMyC,UAAYzC,EAAMvB,SACnDpB,EAAc2D,yBACf8B,GAAgB,GAEpB7D,GAAkB,EACX6D,EAAgBrE,EAAQnB,GAAcC,QAAQyF,SACzD,CAiBA,MAAO,CACHlD,iBACAmD,UAfJ,SAAmB9D,EAAMf,GAErB,GAAIY,EAAMG,GAAMf,WAAaA,EACzB,OAAOb,QAAQyF,UAEnB3F,EAAc6F,iBAAiBP,SAASQ,GAAUA,EAAMC,gBAAgBH,UAAU9D,EAAMf,KACxFY,EAAMG,GAAMf,SAAWA,EACvB,MAAMd,EAAawC,EAAeX,GAClC,IAAK,MAAMwC,KAAO3C,EACdA,EAAM2C,GAAKtD,cAAgB,GAE/B,OAAOf,CACX,EAII+F,mBA5QJ,SAA4BC,GACxB7E,EAAU6E,EAAajG,EAC3B,EA2QIkG,SAAUA,IAAMvE,EAChBwE,MAAOA,KACHxE,EAAQR,IACRS,GAAkB,CAAI,EAGlC"}