{"version":3,"file":"VisualElement.mjs.js","sources":["../../../../../../node_modules/framer-motion/dist/es/render/VisualElement.mjs"],"sourcesContent":["import { KeyframeResolver, time, frame, cancelFrame, transformProps, motionValue, findValueType, complex, getAnimatableNone } from 'motion-dom';\nimport { warnOnce, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = () => {\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState } = visualState;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === \"never\"\n                ? false\n                : this.reducedMotionConfig === \"always\"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n        }\n        if (this.parent)\n            this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform();\n        }\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n        let removeSyncCheck;\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            removeOnRenderRequest();\n            if (removeSyncCheck)\n                removeSyncCheck();\n            if (value.owner)\n                value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = \"animation\";\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition)\n                continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (!this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                }\n                else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = (\"on\" + key);\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue)\n                this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key, target) {\n        let value = this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : this.getBaseTargetFromProps(this.props, key) ??\n                this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\n\nexport { VisualElement };\n"],"names":["propEventHandlers","scrapeMotionValuesFromProps","_props","_prevProps","_visualElement","constructor","parent","props","presenceContext","reducedMotionConfig","blockInitialAnimation","visualState","options","this","current","children","Set","isVariantNode","isControllingVariants","shouldReduceMotion","values","Map","KeyframeResolver","features","valueSubscriptions","prevMotionValues","events","propEventSubscriptions","notifyUpdate","notify","latestValues","render","triggerBuild","renderInstance","renderState","style","projection","renderScheduledAt","scheduleRender","now","time","frame","baseTarget","initialValues","initial","depth","Boolean","variantChildren","manuallyAnimateOnMount","willChange","initialMotionValues","key","value","undefined","isMotionValue","set","mount","instance","visualElementStore","removeFromVariantTree","addVariantChild","forEach","bindToMotionValue","hasReducedMotionListener","initPrefersReducedMotion","prefersReducedMotion","process","env","NODE_ENV","warnOnce","add","update","unmount","cancelFrame","remove","clear","delete","feature","isMounted","has","get","valueIsTransform","transformProps","onBindTransform","removeOnChange","on","latestValue","onUpdate","preRender","isTransformDirty","removeOnRenderRequest","removeSyncCheck","window","MotionCheckAppearSync","owner","stop","sortNodePosition","other","sortInstanceNodePosition","type","updateFeatures","featureDefinitions","featureDefinition","isEnabled","Feature","FeatureConstructor","build","measureViewportBox","measureInstanceViewportBox","createBox","getStaticValue","setStaticValue","transformTemplate","prevProps","prevPresenceContext","i","length","listener","updateMotionValuesFromProps","handleChildMotionValue","getProps","getVariant","name","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getClosestVariantNode","child","closestVariantNode","addValue","existingValue","removeValue","unsubscribe","removeValueFromRenderState","hasValue","getValue","defaultValue","motionValue","readValue","target","getBaseTargetFromProps","readValueFromInstance","isNumericalString","isZeroValueString","parseFloat","findValueType","complex","test","getAnimatableNone","setBaseTarget","getBaseTarget","valueFromInitial","variant","resolveVariantFromProps","custom","eventName","callback","SubscriptionManager","args"],"mappings":"o2CAYA,MAAMA,EAAoB,CACtB,iBACA,oBACA,SACA,sBACA,gBACA,uBACA,iDAMJ,MAQIC,2BAAAA,CAA4BC,EAAQC,EAAYC,GAC5C,MAAO,EACX,CACAC,WAAAA,EAAYC,OAAEA,EAAMC,MAAEA,EAAKC,gBAAEA,EAAeC,oBAAEA,EAAmBC,sBAAEA,EAAqBC,YAAEA,GAAgBC,EAAU,CAAA,GAKhHC,KAAKC,QAAU,KAIfD,KAAKE,SAAW,IAAIC,IAIpBH,KAAKI,eAAgB,EACrBJ,KAAKK,uBAAwB,EAQ7BL,KAAKM,mBAAqB,KAM1BN,KAAKO,OAAS,IAAIC,IAClBR,KAAKS,iBAAmBA,mBAIxBT,KAAKU,SAAW,GAKhBV,KAAKW,mBAAqB,IAAIH,IAM9BR,KAAKY,iBAAmB,GAIxBZ,KAAKa,OAAS,GAMdb,KAAKc,uBAAyB,GAC9Bd,KAAKe,aAAe,IAAMf,KAAKgB,OAAO,SAAUhB,KAAKiB,cACrDjB,KAAKkB,OAAS,KACLlB,KAAKC,UAEVD,KAAKmB,eACLnB,KAAKoB,eAAepB,KAAKC,QAASD,KAAKqB,YAAarB,KAAKN,MAAM4B,MAAOtB,KAAKuB,YAAW,EAE1FvB,KAAKwB,kBAAoB,EACzBxB,KAAKyB,eAAiB,KAClB,MAAMC,EAAMC,OAAKD,MACb1B,KAAKwB,kBAAoBE,IACzB1B,KAAKwB,kBAAoBE,EACzBE,EAAKA,MAACV,OAAOlB,KAAKkB,QAAQ,GAAO,GACrC,EAEJ,MAAMD,aAAEA,EAAYI,YAAEA,GAAgBvB,EACtCE,KAAKiB,aAAeA,EACpBjB,KAAK6B,WAAa,IAAKZ,GACvBjB,KAAK8B,cAAgBpC,EAAMqC,QAAU,IAAKd,GAAiB,GAC3DjB,KAAKqB,YAAcA,EACnBrB,KAAKP,OAASA,EACdO,KAAKN,MAAQA,EACbM,KAAKL,gBAAkBA,EACvBK,KAAKgC,MAAQvC,EAASA,EAAOuC,MAAQ,EAAI,EACzChC,KAAKJ,oBAAsBA,EAC3BI,KAAKD,QAAUA,EACfC,KAAKH,sBAAwBoC,QAAQpC,GACrCG,KAAKK,sBAAwBA,wBAAsBX,GACnDM,KAAKI,cAAgBA,gBAAcV,GAC/BM,KAAKI,gBACLJ,KAAKkC,gBAAkB,IAAI/B,KAE/BH,KAAKmC,uBAAyBF,QAAQxC,GAAUA,EAAOQ,SAWvD,MAAMmC,WAAEA,KAAeC,GAAwBrC,KAAKZ,4BAA4BM,EAAO,CAAE,EAAEM,MAC3F,IAAK,MAAMsC,KAAOD,EAAqB,CACnC,MAAME,EAAQF,EAAoBC,QACRE,IAAtBvB,EAAaqB,IAAsBG,EAAaA,cAACF,IACjDA,EAAMG,IAAIzB,EAAaqB,IAAM,EAErC,CACJ,CACAK,KAAAA,CAAMC,GACF5C,KAAKC,QAAU2C,EACfC,EAAAA,mBAAmBH,IAAIE,EAAU5C,MAC7BA,KAAKuB,aAAevB,KAAKuB,WAAWqB,UACpC5C,KAAKuB,WAAWoB,MAAMC,GAEtB5C,KAAKP,QAAUO,KAAKI,gBAAkBJ,KAAKK,wBAC3CL,KAAK8C,sBAAwB9C,KAAKP,OAAOsD,gBAAgB/C,OAE7DA,KAAKO,OAAOyC,SAAQ,CAACT,EAAOD,IAAQtC,KAAKiD,kBAAkBX,EAAKC,KAC3DW,EAAwBA,yBAACjD,SAC1BkD,EAAAA,2BAEJnD,KAAKM,mBAC4B,UAA7BN,KAAKJ,sBAE8B,WAA7BI,KAAKJ,qBAEDwD,EAAAA,qBAAqBnD,SACN,eAAzBoD,QAAQC,IAAIC,UACZC,EAAAA,UAAqC,IAA5BxD,KAAKM,mBAA6B,0FAE3CN,KAAKP,QACLO,KAAKP,OAAOS,SAASuD,IAAIzD,MAC7BA,KAAK0D,OAAO1D,KAAKN,MAAOM,KAAKL,gBACjC,CACAgE,OAAAA,GACI3D,KAAKuB,YAAcvB,KAAKuB,WAAWoC,UACnCC,cAAY5D,KAAKe,cACjB6C,cAAY5D,KAAKkB,QACjBlB,KAAKW,mBAAmBqC,SAASa,GAAWA,MAC5C7D,KAAKW,mBAAmBmD,QACxB9D,KAAK8C,uBAAyB9C,KAAK8C,wBACnC9C,KAAKP,QAAUO,KAAKP,OAAOS,SAAS6D,OAAO/D,MAC3C,IAAK,MAAMsC,KAAOtC,KAAKa,OACnBb,KAAKa,OAAOyB,GAAKwB,QAErB,IAAK,MAAMxB,KAAOtC,KAAKU,SAAU,CAC7B,MAAMsD,EAAUhE,KAAKU,SAAS4B,GAC1B0B,IACAA,EAAQL,UACRK,EAAQC,WAAY,EAE5B,CACAjE,KAAKC,QAAU,IACnB,CACAgD,iBAAAA,CAAkBX,EAAKC,GACfvC,KAAKW,mBAAmBuD,IAAI5B,IAC5BtC,KAAKW,mBAAmBwD,IAAI7B,EAA5BtC,GAEJ,MAAMoE,EAAmBC,EAAAA,eAAeH,IAAI5B,GACxC8B,GAAoBpE,KAAKsE,iBACzBtE,KAAKsE,kBAET,MAAMC,EAAiBhC,EAAMiC,GAAG,UAAWC,IACvCzE,KAAKiB,aAAaqB,GAAOmC,EACzBzE,KAAKN,MAAMgF,UAAY9C,EAAAA,MAAM+C,UAAU3E,KAAKe,cACxCqD,GAAoBpE,KAAKuB,aACzBvB,KAAKuB,WAAWqD,kBAAmB,EACvC,IAEEC,EAAwBtC,EAAMiC,GAAG,gBAAiBxE,KAAKyB,gBAC7D,IAAIqD,EACAC,OAAOC,wBACPF,EAAkBC,OAAOC,sBAAsBhF,KAAMsC,EAAKC,IAE9DvC,KAAKW,mBAAmB+B,IAAIJ,GAAK,KAC7BiC,IACAM,IACIC,GACAA,IACAvC,EAAM0C,OACN1C,EAAM2C,MAAM,GAExB,CACAC,gBAAAA,CAAiBC,GAIb,OAAKpF,KAAKC,SACLD,KAAKqF,0BACNrF,KAAKsF,OAASF,EAAME,KAGjBtF,KAAKqF,yBAAyBrF,KAAKC,QAASmF,EAAMnF,SAF9C,CAGf,CACAsF,cAAAA,GACI,IAAIjD,EAAM,YACV,IAAKA,KAAOkD,EAAAA,mBAAoB,CAC5B,MAAMC,EAAoBD,qBAAmBlD,GAC7C,IAAKmD,EACD,SACJ,MAAMC,UAAEA,EAAWC,QAASC,GAAuBH,EAYnD,IARKzF,KAAKU,SAAS4B,IACfsD,GACAF,EAAU1F,KAAKN,SACfM,KAAKU,SAAS4B,GAAO,IAAIsD,EAAmB5F,OAK5CA,KAAKU,SAAS4B,GAAM,CACpB,MAAM0B,EAAUhE,KAAKU,SAAS4B,GAC1B0B,EAAQC,UACRD,EAAQN,UAGRM,EAAQrB,QACRqB,EAAQC,WAAY,EAE5B,CACJ,CACJ,CACA9C,YAAAA,GACInB,KAAK6F,MAAM7F,KAAKqB,YAAarB,KAAKiB,aAAcjB,KAAKN,MACzD,CAMAoG,kBAAAA,GACI,OAAO9F,KAAKC,QACND,KAAK+F,2BAA2B/F,KAAKC,QAASD,KAAKN,OACnDsG,EAAAA,WACV,CACAC,cAAAA,CAAe3D,GACX,OAAOtC,KAAKiB,aAAaqB,EAC7B,CACA4D,cAAAA,CAAe5D,EAAKC,GAChBvC,KAAKiB,aAAaqB,GAAOC,CAC7B,CAKAmB,MAAAA,CAAOhE,EAAOC,IACND,EAAMyG,mBAAqBnG,KAAKN,MAAMyG,oBACtCnG,KAAKyB,iBAETzB,KAAKoG,UAAYpG,KAAKN,MACtBM,KAAKN,MAAQA,EACbM,KAAKqG,oBAAsBrG,KAAKL,gBAChCK,KAAKL,gBAAkBA,EAIvB,IAAK,IAAI2G,EAAI,EAAGA,EAAInH,EAAkBoH,OAAQD,IAAK,CAC/C,MAAMhE,EAAMnD,EAAkBmH,GAC1BtG,KAAKc,uBAAuBwB,KAC5BtC,KAAKc,uBAAuBwB,YACrBtC,KAAKc,uBAAuBwB,IAEvC,MACMkE,EAAW9G,EADK,KAAO4C,GAEzBkE,IACAxG,KAAKc,uBAAuBwB,GAAOtC,KAAKwE,GAAGlC,EAAKkE,GAExD,CACAxG,KAAKY,iBAAmB6F,EAAAA,4BAA4BzG,KAAMA,KAAKZ,4BAA4BM,EAAOM,KAAKoG,UAAWpG,MAAOA,KAAKY,kBAC1HZ,KAAK0G,wBACL1G,KAAK0G,wBAEb,CACAC,QAAAA,GACI,OAAO3G,KAAKN,KAChB,CAIAkH,UAAAA,CAAWC,GACP,OAAO7G,KAAKN,MAAMoH,SAAW9G,KAAKN,MAAMoH,SAASD,QAAQrE,CAC7D,CAIAuE,oBAAAA,GACI,OAAO/G,KAAKN,MAAMsH,UACtB,CACAC,qBAAAA,GACI,OAAOjH,KAAKN,MAAMwH,kBACtB,CACAC,qBAAAA,GACI,OAAOnH,KAAKI,cACNJ,KACAA,KAAKP,OACDO,KAAKP,OAAO0H,6BACZ3E,CACd,CAIAO,eAAAA,CAAgBqE,GACZ,MAAMC,EAAqBrH,KAAKmH,wBAChC,GAAIE,EAGA,OAFAA,EAAmBnF,iBACfmF,EAAmBnF,gBAAgBuB,IAAI2D,GACpC,IAAMC,EAAmBnF,gBAAgB6B,OAAOqD,EAE/D,CAIAE,QAAAA,CAAShF,EAAKC,GAEV,MAAMgF,EAAgBvH,KAAKO,OAAO4D,IAAI7B,GAClCC,IAAUgF,IACNA,GACAvH,KAAKwH,YAAYlF,GACrBtC,KAAKiD,kBAAkBX,EAAKC,GAC5BvC,KAAKO,OAAOmC,IAAIJ,EAAKC,GACrBvC,KAAKiB,aAAaqB,GAAOC,EAAM4B,MAEvC,CAIAqD,WAAAA,CAAYlF,GACRtC,KAAKO,OAAOwD,OAAOzB,GACnB,MAAMmF,EAAczH,KAAKW,mBAAmBwD,IAAI7B,GAC5CmF,IACAA,IACAzH,KAAKW,mBAAmBoD,OAAOzB,WAE5BtC,KAAKiB,aAAaqB,GACzBtC,KAAK0H,2BAA2BpF,EAAKtC,KAAKqB,YAC9C,CAIAsG,QAAAA,CAASrF,GACL,OAAOtC,KAAKO,OAAO2D,IAAI5B,EAC3B,CACAsF,QAAAA,CAAStF,EAAKuF,GACV,GAAI7H,KAAKN,MAAMa,QAAUP,KAAKN,MAAMa,OAAO+B,GACvC,OAAOtC,KAAKN,MAAMa,OAAO+B,GAE7B,IAAIC,EAAQvC,KAAKO,OAAO4D,IAAI7B,GAK5B,YAJcE,IAAVD,QAAwCC,IAAjBqF,IACvBtF,EAAQuF,EAAAA,YAA6B,OAAjBD,OAAwBrF,EAAYqF,EAAc,CAAE5C,MAAOjF,OAC/EA,KAAKsH,SAAShF,EAAKC,IAEhBA,CACX,CAMAwF,SAAAA,CAAUzF,EAAK0F,GACX,IAAIzF,OAAmCC,IAA3BxC,KAAKiB,aAAaqB,IAAuBtC,KAAKC,QAEpDD,KAAKiI,uBAAuBjI,KAAKN,MAAO4C,IACtCtC,KAAKkI,sBAAsBlI,KAAKC,QAASqC,EAAKtC,KAAKD,SAFrDC,KAAKiB,aAAaqB,GAcxB,OAXIC,UACqB,iBAAVA,IACN4F,EAAiBA,kBAAC5F,IAAU6F,EAAiBA,kBAAC7F,IAE/CA,EAAQ8F,WAAW9F,IAEb+F,EAAAA,cAAc/F,IAAUgG,EAAAA,QAAQC,KAAKR,KAC3CzF,EAAQkG,EAAiBA,kBAACnG,EAAK0F,IAEnChI,KAAK0I,cAAcpG,EAAKG,gBAAcF,GAASA,EAAM4B,MAAQ5B,IAE1DE,EAAAA,cAAcF,GAASA,EAAM4B,MAAQ5B,CAChD,CAKAmG,aAAAA,CAAcpG,EAAKC,GACfvC,KAAK6B,WAAWS,GAAOC,CAC3B,CAKAoG,aAAAA,CAAcrG,GACV,MAAMP,QAAEA,GAAY/B,KAAKN,MACzB,IAAIkJ,EACJ,GAAuB,iBAAZ7G,GAA2C,iBAAZA,EAAsB,CAC5D,MAAM8G,EAAUC,EAAuBA,wBAAC9I,KAAKN,MAAOqC,EAAS/B,KAAKL,iBAAiBoJ,QAC/EF,IACAD,EAAmBC,EAAQvG,GAEnC,CAIA,GAAIP,QAAgCS,IAArBoG,EACX,OAAOA,EAMX,MAAMZ,EAAShI,KAAKiI,uBAAuBjI,KAAKN,MAAO4C,GACvD,YAAeE,IAAXwF,GAAyBvF,EAAaA,cAACuF,QAMRxF,IAA5BxC,KAAK8B,cAAcQ,SACDE,IAArBoG,OACEpG,EACAxC,KAAK6B,WAAWS,GARX0F,CASf,CACAxD,EAAAA,CAAGwE,EAAWC,GAIV,OAHKjJ,KAAKa,OAAOmI,KACbhJ,KAAKa,OAAOmI,GAAa,IAAIE,EAAmBA,qBAE7ClJ,KAAKa,OAAOmI,GAAWvF,IAAIwF,EACtC,CACAjI,MAAAA,CAAOgI,KAAcG,GACbnJ,KAAKa,OAAOmI,IACZhJ,KAAKa,OAAOmI,GAAWhI,UAAUmI,EAEzC"}