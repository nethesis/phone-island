{"version":3,"file":"PresenceChild.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs"],"sourcesContent":["\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    let isReusedContext = true;\n    let context = useMemo(() => {\n        isReusedContext = false;\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId) => {\n                presenceChildren.set(childId, true);\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n                onExitComplete && onExitComplete();\n            },\n            register: (childId) => {\n                presenceChildren.set(childId, false);\n                return () => presenceChildren.delete(childId);\n            },\n        };\n    }, [isPresent, presenceChildren, onExitComplete]);\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context };\n    }\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, children: children }));\n    }\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n"],"names":["newChildrenMap","Map","PresenceChild","children","initial","isPresent","onExitComplete","custom","presenceAffectsLayout","mode","anchorX","presenceChildren","useConstant","id","useId","isReusedContext","context","useMemo","childId","set","isComplete","values","register","delete","forEach","_","key","React","useEffect","size","jsx","jsxRuntime","exports","PopChild","PresenceContext","Provider","value"],"mappings":"ymBA2DA,SAASA,IACL,OAAO,IAAIC,GACf,uBArDsBC,EAAGC,WAAUC,UAASC,YAAWC,iBAAgBC,SAAQC,wBAAuBC,OAAMC,cACxG,MAAMC,EAAmBC,cAAYZ,GAC/Ba,EAAKC,EAAAA,QACX,IAAIC,GAAkB,EAClBC,EAAUC,EAAAA,SAAQ,KAClBF,GAAkB,EACX,CACHF,KACAT,UACAC,YACAE,SACAD,eAAiBY,IACbP,EAAiBQ,IAAID,GAAS,GAC9B,IAAK,MAAME,KAAcT,EAAiBU,SACtC,IAAKD,EACD,OAERd,GAAkBA,GAAgB,EAEtCgB,SAAWJ,IACPP,EAAiBQ,IAAID,GAAS,GACvB,IAAMP,EAAiBY,OAAOL,OAG9C,CAACb,EAAWM,EAAkBL,IAyBjC,OAnBIE,GAAyBO,IACzBC,EAAU,IAAKA,IAEnBC,EAAAA,SAAQ,KACJN,EAAiBa,SAAQ,CAACC,EAAGC,IAAQf,EAAiBQ,IAAIO,GAAK,IAAO,GACvE,CAACrB,IAKJsB,EAAMC,WAAU,MACXvB,IACIM,EAAiBkB,MAClBvB,GACAA,GAAgB,GACrB,CAACD,IACS,cAATI,IACAN,EAAY2B,EAAGC,WAAAC,QAAAF,IAACG,WAAU,CAAE5B,UAAWA,EAAWK,QAASA,EAASP,SAAUA,KAE1E2B,EAAGC,WAAAC,QAAAF,IAACI,EAAeA,gBAACC,SAAU,CAAEC,MAAOpB,EAASb,SAAUA,GAAW"}