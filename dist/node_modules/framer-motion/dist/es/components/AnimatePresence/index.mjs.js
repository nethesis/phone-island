"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),require("../../../../../react/jsx-runtime.js");var e=require("react"),t=require("../../context/LayoutGroupContext.mjs.js"),s=require("../../utils/use-constant.mjs.js"),r=require("../../utils/use-isomorphic-effect.mjs.js"),n=require("./PresenceChild.mjs.js"),i=require("./use-presence.mjs.js"),o=require("./utils.mjs.js"),u=require("../../../../../../_virtual/jsx-runtime.js");exports.AnimatePresence=({children:c,custom:l,initial:a=!0,onExitComplete:m,presenceAffectsLayout:d=!0,mode:p="sync",propagate:h=!1,anchorX:j="left"})=>{const[f,x]=i.usePresence(h),g=e.useMemo((()=>o.onlyElements(c)),[c]),y=h&&!f?[]:g.map(o.getChildKey),C=e.useRef(!0),q=e.useRef(g),v=s.useConstant((()=>new Map)),[E,w]=e.useState(g),[P,R]=e.useState(g);r.useIsomorphicLayoutEffect((()=>{C.current=!1,q.current=g;for(let e=0;e<P.length;e++){const t=o.getChildKey(P[e]);y.includes(t)?v.delete(t):!0!==v.get(t)&&v.set(t,!1)}}),[P,y.length,y.join("-")]);const L=[];if(g!==E){let e=[...g];for(let t=0;t<P.length;t++){const s=P[t],r=o.getChildKey(s);y.includes(r)||(e.splice(t,0,s),L.push(s))}return"wait"===p&&L.length&&(e=L),R(o.onlyElements(e)),w(g),null}"production"!==process.env.NODE_ENV&&"wait"===p&&P.length>1&&console.warn('You\'re attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.');const{forceRender:A}=e.useContext(t.LayoutGroupContext);return u.jsxRuntime.exports.jsx(u.jsxRuntime.exports.Fragment,{children:P.map((e=>{const t=o.getChildKey(e),s=!(h&&!f)&&(g===P||y.includes(t));return u.jsxRuntime.exports.jsx(n.PresenceChild,{isPresent:s,initial:!(C.current&&!a)&&void 0,custom:l,presenceAffectsLayout:d,mode:p,onExitComplete:s?void 0:()=>{if(!v.has(t))return;v.set(t,!0);let e=!0;v.forEach((t=>{t||(e=!1)})),e&&(A?.(),R(q.current),h&&x?.(),m&&m())},anchorX:j,children:e},t)}))})};
//# sourceMappingURL=index.mjs.js.map
