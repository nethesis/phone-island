{"version":3,"file":"index.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"sourcesContent":["\"use client\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, anchorX = \"left\", }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null;\n    }\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext);\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender?.();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && safeToRemove?.();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\nexport { AnimatePresence };\n"],"names":["AnimatePresence","children","custom","initial","onExitComplete","presenceAffectsLayout","mode","propagate","anchorX","isParentPresent","safeToRemove","usePresence","presentChildren","useMemo","onlyElements","presentKeys","map","getChildKey","isInitialRender","useRef","pendingPresentChildren","exitComplete","useConstant","Map","diffedChildren","setDiffedChildren","useState","renderedChildren","setRenderedChildren","useIsomorphicLayoutEffect","current","i","length","key","includes","delete","get","set","join","exitingChildren","nextChildren","child","splice","push","process","env","NODE_ENV","console","warn","forceRender","useContext","LayoutGroupContext","jsx","Fragment","isPresent","PresenceChild","undefined","onExit","has","isEveryExitComplete","forEach","isExitComplete"],"mappings":"odA2CwBA,EAAGC,WAAUC,SAAQC,WAAU,EAAMC,iBAAgBC,yBAAwB,EAAMC,OAAO,OAAQC,aAAY,EAAOC,UAAU,WACnJ,MAAOC,EAAiBC,GAAgBC,EAAWA,YAACJ,GAK9CK,EAAkBC,EAAAA,SAAQ,IAAMC,EAAAA,aAAab,IAAW,CAACA,IAKzDc,EAAcR,IAAcE,EAAkB,GAAKG,EAAgBI,IAAIC,EAAAA,aAIvEC,EAAkBC,UAAO,GAMzBC,EAAyBD,SAAOP,GAIhCS,EAAeC,EAAWA,aAAC,IAAM,IAAIC,OAKpCC,EAAgBC,GAAqBC,EAAQA,SAACd,IAC9Ce,EAAkBC,GAAuBF,EAAQA,SAACd,GACzDiB,EAAAA,2BAA0B,KACtBX,EAAgBY,SAAU,EAC1BV,EAAuBU,QAAUlB,EAIjC,IAAK,IAAImB,EAAI,EAAGA,EAAIJ,EAAiBK,OAAQD,IAAK,CAC9C,MAAME,EAAMhB,EAAWA,YAACU,EAAiBI,IACpChB,EAAYmB,SAASD,GAMtBZ,EAAac,OAAOF,IALU,IAA1BZ,EAAae,IAAIH,IACjBZ,EAAagB,IAAIJ,GAAK,EAMlC,IACD,CAACN,EAAkBZ,EAAYiB,OAAQjB,EAAYuB,KAAK,OAC3D,MAAMC,EAAkB,GACxB,GAAI3B,IAAoBY,EAAgB,CACpC,IAAIgB,EAAe,IAAI5B,GAKvB,IAAK,IAAImB,EAAI,EAAGA,EAAIJ,EAAiBK,OAAQD,IAAK,CAC9C,MAAMU,EAAQd,EAAiBI,GACzBE,EAAMhB,cAAYwB,GACnB1B,EAAYmB,SAASD,KACtBO,EAAaE,OAAOX,EAAG,EAAGU,GAC1BF,EAAgBI,KAAKF,GAE7B,CAcA,MATa,SAATnC,GAAmBiC,EAAgBP,SACnCQ,EAAeD,GAEnBX,EAAoBd,EAAAA,aAAa0B,IACjCf,EAAkBb,GAKX,IACX,CAC6B,eAAzBgC,QAAQC,IAAIC,UACH,SAATxC,GACAqB,EAAiBK,OAAS,GAC1Be,QAAQC,KAAK,kJAOjB,MAAMC,YAAEA,GAAgBC,EAAAA,WAAWC,EAAAA,oBACnC,OAAQC,EAAAA,WAAAA,QAAAA,IAAIC,EAAAA,WAAAA,QAAAA,SAAU,CAAEpD,SAAU0B,EAAiBX,KAAKyB,IAChD,MAAMR,EAAMhB,cAAYwB,GAClBa,IAAY/C,IAAcE,KAE1BG,IAAoBe,GAClBZ,EAAYmB,SAASD,IAoB7B,OAAQmB,EAAAA,WAAAA,QAAAA,IAAIG,EAAAA,cAAe,CAAED,UAAWA,EAAWnD,UAAUe,EAAgBY,UAAW3B,SAC9EqD,EACOtD,OAAQA,EAAQG,sBAAuBA,EAAuBC,KAAMA,EAAMF,eAAgBkD,OAAYE,EArBxGC,KACX,IAAIpC,EAAaqC,IAAIzB,GAIjB,OAHAZ,EAAagB,IAAIJ,GAAK,GAK1B,IAAI0B,GAAsB,EAC1BtC,EAAauC,SAASC,IACbA,IACDF,GAAsB,EAAK,IAE/BA,IACAV,MACArB,EAAoBR,EAAuBU,SAC3CvB,GAAaG,MACbN,GAAkBA,IACtB,EAIuII,QAASA,EAASP,SAAUwC,GAASR,EAAI,KACnL"}