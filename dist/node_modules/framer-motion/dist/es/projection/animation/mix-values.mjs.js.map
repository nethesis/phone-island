{"version":3,"file":"mix-values.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs"],"sourcesContent":["import { mixNumber, percent, px } from 'motion-dom';\nimport { progress, circOut, noop } from 'motion-utils';\n\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);\nfunction compress(min, max, easing) {\n    return (p) => {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\nexport { mixValues };\n"],"names":["borders","numBorders","length","asNumber","value","parseFloat","isPx","px","test","getRadius","values","radiusName","undefined","borderRadius","easeCrossfadeIn","compress","circOut","easeCrossfadeOut","noop","min","max","easing","p","progress","target","follow","lead","shouldCrossfadeOpacity","isOnlyMember","opacity","mixNumber","opacityExit","i","borderLabel","followRadius","leadRadius","Math","percent","rotate"],"mappings":"iaAGA,MAAMA,EAAU,CAAC,UAAW,WAAY,aAAc,eAChDC,EAAaD,EAAQE,OACrBC,EAAYC,GAA2B,iBAAVA,EAAqBC,WAAWD,GAASA,EACtEE,EAAQF,GAA2B,iBAAVA,GAAsBG,KAAGC,KAAKJ,GAwC7D,SAASK,EAAUC,EAAQC,GACvB,YAA8BC,IAAvBF,EAAOC,GACRD,EAAOC,GACPD,EAAOG,YACjB,CAwBA,MAAMC,EAAgCC,EAAS,EAAG,GAAKC,EAAOA,SACxDC,EAAiCF,EAAS,GAAK,IAAMG,EAAIA,MAC/D,SAASH,EAASI,EAAKC,EAAKC,GACxB,OAAQC,GAEAA,EAAIH,EACG,EACPG,EAAIF,EACG,EACJC,EAAOE,EAAAA,SAASJ,EAAKC,EAAKE,GAEzC,mBA9EA,SAAmBE,EAAQC,EAAQC,EAAMH,EAAUI,EAAwBC,GACnED,GACAH,EAAOK,QAAUC,EAASA,UAAC,EAAGJ,EAAKG,SAAW,EAAGf,EAAgBS,IACjEC,EAAOO,YAAcD,EAASA,UAACL,EAAOI,SAAW,EAAG,EAAGZ,EAAiBM,KAEnEK,IACLJ,EAAOK,QAAUC,YAAUL,EAAOI,SAAW,EAAGH,EAAKG,SAAW,EAAGN,IAKvE,IAAK,IAAIS,EAAI,EAAGA,EAAI/B,EAAY+B,IAAK,CACjC,MAAMC,EAAc,SAASjC,EAAQgC,WACrC,IAAIE,EAAezB,EAAUgB,EAAQQ,GACjCE,EAAa1B,EAAUiB,EAAMO,GACjC,QAAqBrB,IAAjBsB,QAA6CtB,IAAfuB,EAC9B,SACJD,IAAiBA,EAAe,GAChCC,IAAeA,EAAa,GACI,IAAjBD,GACI,IAAfC,GACA7B,EAAK4B,KAAkB5B,EAAK6B,IAE5BX,EAAOS,GAAeG,KAAKhB,IAAIU,EAASA,UAAC3B,EAAS+B,GAAe/B,EAASgC,GAAaZ,GAAW,IAC9Fc,EAAAA,QAAQ7B,KAAK2B,IAAeE,EAAAA,QAAQ7B,KAAK0B,MACzCV,EAAOS,IAAgB,MAI3BT,EAAOS,GAAeE,CAE9B,EAIIV,EAAOa,QAAUZ,EAAKY,UACtBd,EAAOc,OAASR,YAAUL,EAAOa,QAAU,EAAGZ,EAAKY,QAAU,EAAGf,GAExE"}