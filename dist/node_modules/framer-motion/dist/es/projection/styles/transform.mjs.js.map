{"version":3,"file":"transform.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/projection/styles/transform.mjs"],"sourcesContent":["function buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = latestTransform?.z || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nexport { buildProjectionTransform };\n"],"names":["delta","treeScale","latestTransform","transform","xTranslate","x","translate","yTranslate","y","zTranslate","z","transformPerspective","rotate","rotateX","rotateY","skewX","skewY","elementScaleX","scale","elementScaleY"],"mappings":"qGAAA,SAAkCA,EAAOC,EAAWC,GAChD,IAAIC,EAAY,GAOhB,MAAMC,EAAaJ,EAAMK,EAAEC,UAAYL,EAAUI,EAC3CE,EAAaP,EAAMQ,EAAEF,UAAYL,EAAUO,EAC3CC,EAAaP,GAAiBQ,GAAK,EAWzC,IAVIN,GAAcG,GAAcE,KAC5BN,EAAY,eAAeC,QAAiBG,QAAiBE,SAM7C,IAAhBR,EAAUI,GAA2B,IAAhBJ,EAAUO,IAC/BL,GAAa,SAAS,EAAIF,EAAUI,MAAM,EAAIJ,EAAUO,OAExDN,EAAiB,CACjB,MAAMS,qBAAEA,EAAoBC,OAAEA,EAAMC,QAAEA,EAAOC,QAAEA,EAAOC,MAAEA,EAAKC,MAAEA,GAAUd,EACrES,IACAR,EAAY,eAAeQ,QAA2BR,KACtDS,IACAT,GAAa,UAAUS,UACvBC,IACAV,GAAa,WAAWU,UACxBC,IACAX,GAAa,WAAWW,UACxBC,IACAZ,GAAa,SAASY,UACtBC,IACAb,GAAa,SAASa,SAC9B,CAKA,MAAMC,EAAgBjB,EAAMK,EAAEa,MAAQjB,EAAUI,EAC1Cc,EAAgBnB,EAAMQ,EAAEU,MAAQjB,EAAUO,EAIhD,OAHsB,IAAlBS,GAAyC,IAAlBE,IACvBhB,GAAa,SAASc,MAAkBE,MAErChB,GAAa,MACxB"}