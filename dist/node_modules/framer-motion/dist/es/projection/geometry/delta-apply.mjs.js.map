{"version":3,"file":"delta-apply.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { mixNumber } from 'motion-dom';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n"],"names":["scalePoint","point","scale","originPoint","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","min","max","applyBoxDelta","box","x","y","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","transformAxis","axisTranslate","axisScale","axisOrigin","mixNumber","transformBox","transform","scaleX","originX","scaleY","originY","treeScale","treePath","isSharedTransition","treeLength","length","node","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","offset","hasTransform","latestValues","distance"],"mappings":"0LAMA,SAASA,EAAWC,EAAOC,EAAOC,GAG9B,OAAOA,EADQD,GADYD,EAAQE,EAGvC,CAIA,SAASC,EAAgBH,EAAOI,EAAWH,EAAOC,EAAaG,GAI3D,YAHiBC,IAAbD,IACAL,EAAQD,EAAWC,EAAOK,EAAUH,IAEjCH,EAAWC,EAAOC,EAAOC,GAAeE,CACnD,CAIA,SAASG,EAAeC,EAAMJ,EAAY,EAAGH,EAAQ,EAAGC,EAAaG,GACjEG,EAAKC,IAAMN,EAAgBK,EAAKC,IAAKL,EAAWH,EAAOC,EAAaG,GACpEG,EAAKE,IAAMP,EAAgBK,EAAKE,IAAKN,EAAWH,EAAOC,EAAaG,EACxE,CAIA,SAASM,EAAcC,GAAKC,EAAEA,EAACC,EAAEA,IAC7BP,EAAeK,EAAIC,EAAGA,EAAET,UAAWS,EAAEZ,MAAOY,EAAEX,aAC9CK,EAAeK,EAAIE,EAAGA,EAAEV,UAAWU,EAAEb,MAAOa,EAAEZ,YAClD,CACA,MAAMa,EAAsB,cACtBC,EAAsB,gBAsE5B,SAASC,EAAcT,EAAMU,EAAeC,EAAWd,EAAUe,EAAa,IAG1Eb,EAAeC,EAAMU,EAAeC,EAFhBE,EAAAA,UAAUb,EAAKC,IAAKD,EAAKE,IAAKU,GAEUf,EAChE,CAIA,SAASiB,EAAaV,EAAKW,GACvBN,EAAcL,EAAIC,EAAGU,EAAUV,EAAGU,EAAUC,OAAQD,EAAUtB,MAAOsB,EAAUE,SAC/ER,EAAcL,EAAIE,EAAGS,EAAUT,EAAGS,EAAUG,OAAQH,EAAUtB,MAAOsB,EAAUI,QACnF,oGA1EA,SAAyBf,EAAKgB,EAAWC,EAAUC,GAAqB,GACpE,MAAMC,EAAaF,EAASG,OAC5B,IAAKD,EACD,OAGJ,IAAIE,EACAC,EAFJN,EAAUf,EAAIe,EAAUd,EAAI,EAG5B,IAAK,IAAIqB,EAAI,EAAGA,EAAIJ,EAAYI,IAAK,CACjCF,EAAOJ,EAASM,GAChBD,EAAQD,EAAKG,gBAKb,MAAMC,cAAEA,GAAkBJ,EAAKK,QAC3BD,GACAA,EAAcE,MAAMC,OACkB,aAAtCH,EAAcE,MAAMC,MAAMC,UAG1BX,GACAG,EAAKK,QAAQI,cACbT,EAAKU,QACLV,IAASA,EAAKW,MACdtB,EAAaV,EAAK,CACdC,GAAIoB,EAAKU,OAAOE,OAAOhC,EACvBC,GAAImB,EAAKU,OAAOE,OAAO/B,IAG3BoB,IAEAN,EAAUf,GAAKqB,EAAMrB,EAAEZ,MACvB2B,EAAUd,GAAKoB,EAAMpB,EAAEb,MAEvBU,EAAcC,EAAKsB,IAEnBJ,GAAsBgB,EAAAA,aAAab,EAAKc,eACxCzB,EAAaV,EAAKqB,EAAKc,cAE/B,CAKInB,EAAUf,EAAIG,GACdY,EAAUf,EAAIE,IACda,EAAUf,EAAI,GAEde,EAAUd,EAAIE,GACdY,EAAUd,EAAIC,IACda,EAAUd,EAAI,EAEtB,4FACA,SAAuBN,EAAMwC,GACzBxC,EAAKC,IAAMD,EAAKC,IAAMuC,EACtBxC,EAAKE,IAAMF,EAAKE,IAAMsC,CAC1B"}