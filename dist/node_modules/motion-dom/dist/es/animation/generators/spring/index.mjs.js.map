{"version":3,"file":"index.mjs.js","sources":["../../../../../../../../node_modules/motion-dom/dist/es/animation/generators/spring/index.mjs"],"sourcesContent":["import { millisecondsToSeconds, secondsToMilliseconds, clamp } from 'motion-utils';\nimport { generateLinearEasing } from '../../waapi/utils/linear.mjs';\nimport { calcGeneratorDuration, maxGeneratorDuration } from '../utils/calc-duration.mjs';\nimport { createGeneratorEasing } from '../utils/create-generator-easing.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = t === 0 ? initialVelocity : 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n        toTransition: () => { },\n    };\n    return generator;\n}\nspring.applyToOptions = (options) => {\n    const generatorOptions = createGeneratorEasing(options, 100, spring);\n    options.ease = generatorOptions.ease;\n    options.duration = secondsToMilliseconds(generatorOptions.duration);\n    options.type = \"keyframes\";\n    return options;\n};\n\nexport { spring };\n"],"names":["durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","spring","optionsOrVisualDuration","springDefaults","visualDuration","bounce","keyframes","restSpeed","restDelta","origin","target","length","state","done","value","stiffness","damping","mass","duration","velocity","isResolvedFromDuration","springOptions","root","Math","PI","clamp","sqrt","derived","findSpring","getSpringOptions","millisecondsToSeconds","initialVelocity","dampingRatio","initialDelta","undampedAngularFreq","isGranularScale","abs","resolveSpring","granular","default","angularFreq","calcAngularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","current","currentVelocity","secondsToMilliseconds","calcGeneratorVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","calcGeneratorDuration","maxGeneratorDuration","easing","generateLinearEasing","progress","toTransition","applyToOptions","generatorOptions","createGeneratorEasing","ease","type"],"mappings":"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"}