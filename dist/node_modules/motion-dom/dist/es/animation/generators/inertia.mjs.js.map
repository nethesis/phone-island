{"version":3,"file":"inertia.mjs.js","sources":["../../../../../../../node_modules/motion-dom/dist/es/animation/generators/inertia.mjs"],"sourcesContent":["import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n"],"names":["keyframes","velocity","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","min","max","restDelta","restSpeed","origin","state","done","value","nearestBoundary","v","undefined","Math","abs","amplitude","ideal","target","calcDelta","t","exp","calcLatest","applyFriction","delta","latest","timeReachedBoundary","spring$1","checkCatchBoundary","spring","calcGeneratorVelocity","damping","stiffness","calculatedDuration","next","hasUpdatedFrame"],"mappings":"gKAGA,UAAiBA,UAAEA,EAAWC,SAAAA,EAAW,EAAGC,MAAEA,EAAQ,GAAGC,aAAEA,EAAe,IAAGC,cAAEA,EAAgB,GAAEC,gBAAEA,EAAkB,IAAGC,aAAEA,EAAYC,IAAEA,EAAGC,IAAEA,EAAGC,UAAEA,EAAY,GAAGC,UAAEA,IAC/J,MAAMC,EAASX,EAAU,GACnBY,EAAQ,CACVC,MAAM,EACNC,MAAOH,GAGLI,EAAmBC,QACTC,IAARV,EACOC,OACCS,IAART,GAEGU,KAAKC,IAAIZ,EAAMS,GAAKE,KAAKC,IAAIX,EAAMQ,GAD/BT,EAC0CC,EAEzD,IAAIY,EAAYlB,EAAQD,EACxB,MAAMoB,EAAQV,EAASS,EACjBE,OAA0BL,IAAjBX,EAA6Be,EAAQf,EAAae,GAK7DC,IAAWD,IACXD,EAAYE,EAASX,GACzB,MAAMY,EAAaC,IAAOJ,EAAYF,KAAKO,KAAKD,EAAIrB,GAC9CuB,EAAcF,GAAMF,EAASC,EAAUC,GACvCG,EAAiBH,IACnB,MAAMI,EAAQL,EAAUC,GAClBK,EAASH,EAAWF,GAC1BZ,EAAMC,KAAOK,KAAKC,IAAIS,IAAUnB,EAChCG,EAAME,MAAQF,EAAMC,KAAOS,EAASO,CAAM,EAQ9C,IAAIC,EACAC,EACJ,MAAMC,EAAsBR,IAjCLR,SAkCAJ,EAAME,WAlCSG,IAARV,GAAqBS,EAAIT,QAAiBU,IAART,GAAqBQ,EAAIR,KAoCrFsB,EAAsBN,EACtBO,EAAWE,EAAAA,OAAO,CACdjC,UAAW,CAACY,EAAME,MAAOC,EAAgBH,EAAME,QAC/Cb,SAAUiC,EAAAA,sBAAsBR,EAAYF,EAAGZ,EAAME,OACrDqB,QAAS/B,EACTgC,UAAW/B,EACXI,YACAC,cACF,EAGN,OADAsB,EAAmB,GACZ,CACHK,mBAAoB,KACpBC,KAAOd,IAOH,IAAIe,GAAkB,EAUtB,OATKR,QAAoCd,IAAxBa,IACbS,GAAkB,EAClBZ,EAAcH,GACdQ,EAAmBR,SAMKP,IAAxBa,GAAqCN,GAAKM,EACnCC,EAASO,KAAKd,EAAIM,KAGxBS,GAAmBZ,EAAcH,GAC3BZ,EACX,EAGZ"}