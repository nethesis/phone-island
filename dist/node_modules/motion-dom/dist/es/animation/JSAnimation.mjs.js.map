{"version":3,"file":"JSAnimation.mjs.js","sources":["../../../../../../node_modules/motion-dom/dist/es/animation/JSAnimation.mjs"],"sourcesContent":["import { invariant, pipe, clamp, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { activeAnimations } from '../stats/animation-count.mjs';\nimport { mix } from '../utils/mix/index.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { inertia } from './generators/inertia.mjs';\nimport { keyframes } from './generators/keyframes.mjs';\nimport { calcGeneratorDuration } from './generators/utils/calc-duration.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\n\nconst percentToProgress = (percent) => percent / 100;\nclass JSAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.state = \"idle\";\n        this.startTime = null;\n        this.isStopped = false;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            const { motionValue } = this.options;\n            if (motionValue && motionValue.updatedAt !== time.now()) {\n                this.tick(time.now());\n            }\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        activeAnimations.mainThread++;\n        this.options = options;\n        this.initAnimation();\n        this.play();\n        if (options.autoplay === false)\n            this.pause();\n    }\n    initAnimation() {\n        const { options } = this;\n        replaceTransitionType(options);\n        const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = options;\n        let { keyframes: keyframes$1 } = options;\n        const generatorFactory = type || keyframes;\n        if (process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframes) {\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n        }\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            this.mirroredGenerator = generatorFactory({\n                ...options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        this.calculatedDuration = calculatedDuration;\n        this.resolvedDuration = calculatedDuration + repeatDelay;\n        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;\n        this.generator = generator;\n    }\n    updateTime(timestamp) {\n        const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;\n        // Update currentTime\n        if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = animationTime;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = this;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay = 0, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else {\n            this.updateTime(timestamp);\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.playbackSpeed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mixKeyframes) {\n            state.value = mixKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.playbackSpeed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        // TODO: The exception for inertia could be cleaner here\n        if (isAnimationFinished && type !== inertia) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.finished.then(resolve, reject);\n    }\n    get duration() {\n        return millisecondsToSeconds(this.calculatedDuration);\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.startTime === null ||\n            this.holdTime !== null ||\n            this.playbackSpeed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.playbackSpeed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        this.updateTime(time.now());\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n            this.startTime = now;\n        }\n        else if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime ?? now;\n        }\n        if (this.state === \"finished\" && this.speed < 0) {\n            this.startTime += this.calculatedDuration;\n        }\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        this.state = \"paused\";\n        this.updateTime(time.now());\n        this.holdTime = this.currentTime;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        this.holdTime = null;\n        this.startTime = 0;\n        this.tick(0);\n        this.teardown();\n    }\n    teardown() {\n        this.notifyFinished();\n        this.state = \"idle\";\n        this.stopDriver();\n        this.startTime = this.holdTime = null;\n        activeAnimations.mainThread--;\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(sampleTime) {\n        this.startTime = 0;\n        return this.tick(sampleTime, true);\n    }\n    attachTimeline(timeline) {\n        if (this.options.allowFlatten) {\n            this.options.type = \"keyframes\";\n            this.options.ease = \"linear\";\n            this.initAnimation();\n        }\n        return timeline.observe(this);\n    }\n}\n// Legacy function support\nfunction animateValue(options) {\n    return new JSAnimation(options);\n}\n\nexport { JSAnimation, animateValue };\n"],"names":["percentToProgress","percent","JSAnimation","WithPromise","constructor","options","super","this","state","startTime","isStopped","currentTime","holdTime","playbackSpeed","stop","motionValue","updatedAt","time","now","tick","teardown","onStop","activeAnimations","mainThread","initAnimation","play","autoplay","pause","replaceTransitionType","type","keyframes","repeat","repeatDelay","repeatType","velocity","keyframes$1","generatorFactory","process","env","NODE_ENV","invariant","length","mixKeyframes","pipe","mix","generator","mirroredGenerator","reverse","calculatedDuration","calcGeneratorDuration","resolvedDuration","totalDuration","updateTime","timestamp","animationTime","Math","round","sample","next","delay","onUpdate","finalKeyframe","speed","min","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","Boolean","clamp","done","value","isAnimationFinished","inertia","getFinalKeyframe","finish","then","resolve","reject","finished","duration","millisecondsToSeconds","newTime","secondsToMilliseconds","driver","newSpeed","hasChanged","frameloopDriver","onPlay","updateFinished","start","complete","onComplete","cancel","notifyFinished","stopDriver","undefined","sampleTime","attachTimeline","timeline","allowFlatten","ease","observe"],"mappings":"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"}