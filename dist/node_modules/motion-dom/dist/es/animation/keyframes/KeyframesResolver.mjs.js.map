{"version":3,"file":"KeyframesResolver.mjs.js","sources":["../../../../../../../node_modules/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs"],"sourcesContent":["import { fillWildcards } from './utils/fill-wildcards.mjs';\nimport { removeNonTranslationalTransform } from './utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nlet isForced = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    element.getValue(key)?.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete(isForced));\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    isForced = true;\n    readAllKeyframes();\n    measureAllKeyframes();\n    isForced = false;\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        /**\n         * Track whether this resolver has completed. Once complete, it never\n         * needs to attempt keyframe resolution again.\n         */\n        this.isComplete = false;\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        /**\n         * Track whether this resolver is currently scheduled to resolve\n         * to allow it to be cancelled and resumed externally.\n         */\n        this.isScheduled = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.isScheduled = true;\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        // If initial keyframe is null we need to read it from the DOM\n        if (unresolvedKeyframes[0] === null) {\n            const currentValue = motionValue?.get();\n            // TODO: This doesn't work if the final keyframe is a wildcard\n            const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n            if (currentValue !== undefined) {\n                unresolvedKeyframes[0] = currentValue;\n            }\n            else if (element && name) {\n                const valueAsRead = element.readValue(name, finalKeyframe);\n                if (valueAsRead !== undefined && valueAsRead !== null) {\n                    unresolvedKeyframes[0] = valueAsRead;\n                }\n            }\n            if (unresolvedKeyframes[0] === undefined) {\n                unresolvedKeyframes[0] = finalKeyframe;\n            }\n            if (motionValue && currentValue === undefined) {\n                motionValue.set(unresolvedKeyframes[0]);\n            }\n        }\n        fillWildcards(unresolvedKeyframes);\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete(isForced = false) {\n        this.isComplete = true;\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForced);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (!this.isComplete) {\n            this.isScheduled = false;\n            toResolve.delete(this);\n        }\n    }\n    resume() {\n        if (!this.isComplete)\n            this.scheduleResolve();\n    }\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };\n"],"names":["toResolve","Set","isScheduled","anyNeedsMeasurement","isForced","measureAllKeyframes","resolversToMeasure","Array","from","filter","resolver","needsMeasurement","elementsToMeasure","map","element","transformsToRestore","Map","forEach","removedTransforms","removeNonTranslationalTransform","length","set","render","measureInitialState","restore","get","key","value","getValue","measureEndState","undefined","suspendedScrollY","window","scrollTo","complete","clear","readAllKeyframes","readKeyframes","constructor","unresolvedKeyframes","onComplete","name","motionValue","isAsync","this","isComplete","scheduleResolve","add","frame","read","resolveKeyframes","currentValue","finalKeyframe","valueAsRead","readValue","fillWildcards","setFinalKeyframe","renderEndStyles","delete","cancel","resume"],"mappings":"yMAIA,MAAMA,EAAY,IAAIC,IACtB,IAAIC,GAAc,EACdC,GAAsB,EACtBC,GAAW,EACf,SAASC,IACL,GAAIF,EAAqB,CACrB,MAAMG,EAAqBC,MAAMC,KAAKR,GAAWS,QAAQC,GAAaA,EAASC,mBACzEC,EAAoB,IAAIX,IAAIK,EAAmBO,KAAKH,GAAaA,EAASI,WAC1EC,EAAsB,IAAIC,IAKhCJ,EAAkBK,SAASH,IACvB,MAAMI,EAAoBC,kCAAgCL,GACrDI,EAAkBE,SAEvBL,EAAoBM,IAAIP,EAASI,GACjCJ,EAAQQ,SAAQ,IAGpBhB,EAAmBW,SAASP,GAAaA,EAASa,wBAElDX,EAAkBK,SAASH,IACvBA,EAAQQ,SACR,MAAME,EAAUT,EAAoBU,IAAIX,GACpCU,GACAA,EAAQP,SAAQ,EAAES,EAAKC,MACnBb,EAAQc,SAASF,IAAML,IAAIM,EAAM,GAEzC,IAGJrB,EAAmBW,SAASP,GAAaA,EAASmB,oBAElDvB,EAAmBW,SAASP,SACUoB,IAA9BpB,EAASqB,kBACTC,OAAOC,SAAS,EAAGvB,EAASqB,iBAChC,GAER,CACA5B,GAAsB,EACtBD,GAAc,EACdF,EAAUiB,SAASP,GAAaA,EAASwB,SAAS9B,KAClDJ,EAAUmC,OACd,CACA,SAASC,IACLpC,EAAUiB,SAASP,IACfA,EAAS2B,gBACL3B,EAASC,mBACTR,GAAsB,EAC1B,GAER,0BAOA,MACImC,WAAAA,CAAYC,EAAqBC,EAAYC,EAAMC,EAAa5B,EAAS6B,GAAU,GAK/EC,KAAKC,YAAa,EAMlBD,KAAKD,SAAU,EAKfC,KAAKjC,kBAAmB,EAKxBiC,KAAK1C,aAAc,EACnB0C,KAAKL,oBAAsB,IAAIA,GAC/BK,KAAKJ,WAAaA,EAClBI,KAAKH,KAAOA,EACZG,KAAKF,YAAcA,EACnBE,KAAK9B,QAAUA,EACf8B,KAAKD,QAAUA,CACnB,CACAG,eAAAA,GACIF,KAAK1C,aAAc,EACf0C,KAAKD,SACL3C,EAAU+C,IAAIH,MACT1C,IACDA,GAAc,EACd8C,QAAMC,KAAKb,GACXY,QAAME,iBAAiB7C,MAI3BuC,KAAKP,gBACLO,KAAKV,WAEb,CACAG,aAAAA,GACI,MAAME,oBAAEA,EAAmBE,KAAEA,EAAI3B,QAAEA,EAAO4B,YAAEA,GAAgBE,KAE5D,GAA+B,OAA3BL,EAAoB,GAAa,CACjC,MAAMY,EAAeT,GAAajB,MAE5B2B,EAAgBb,EAAoBA,EAAoBnB,OAAS,GACvE,QAAqBU,IAAjBqB,EACAZ,EAAoB,GAAKY,OAExB,GAAIrC,GAAW2B,EAAM,CACtB,MAAMY,EAAcvC,EAAQwC,UAAUb,EAAMW,GACxCC,UACAd,EAAoB,GAAKc,EAEjC,MAC+BvB,IAA3BS,EAAoB,KACpBA,EAAoB,GAAKa,GAEzBV,QAAgCZ,IAAjBqB,GACfT,EAAYrB,IAAIkB,EAAoB,GAE5C,CACAgB,EAAaA,cAAChB,EAClB,CACAiB,gBAAAA,GAAqB,CACrBjC,mBAAAA,GAAwB,CACxBkC,eAAAA,GAAoB,CACpB5B,eAAAA,GAAoB,CACpBK,QAAAA,CAAS9B,GAAW,GAChBwC,KAAKC,YAAa,EAClBD,KAAKJ,WAAWI,KAAKL,oBAAqBK,KAAKQ,cAAehD,GAC9DJ,EAAU0D,OAAOd,KACrB,CACAe,MAAAA,GACSf,KAAKC,aACND,KAAK1C,aAAc,EACnBF,EAAU0D,OAAOd,MAEzB,CACAgB,MAAAA,GACShB,KAAKC,YACND,KAAKE,iBACb,kCA9FJ,WACI1C,GAAW,EACXgC,IACA/B,IACAD,GAAW,CACf"}