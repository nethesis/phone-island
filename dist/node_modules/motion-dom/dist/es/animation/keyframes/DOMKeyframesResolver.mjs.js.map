{"version":3,"file":"DOMKeyframesResolver.mjs.js","sources":["../../../../../../../node_modules/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs"],"sourcesContent":["import { positionalKeys } from '../../render/utils/keys-position.mjs';\nimport { findDimensionValueType } from '../../value/types/dimensions.mjs';\nimport { getVariableValue } from '../utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from '../utils/is-css-variable.mjs';\nimport { KeyframeResolver } from './KeyframesResolver.mjs';\nimport { isNone } from './utils/is-none.mjs';\nimport { makeNoneKeyframesAnimatable } from './utils/make-none-animatable.mjs';\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null ||\n                isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if (this.removedTransforms?.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n"],"names":["DOMKeyframesResolver","KeyframeResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","element","super","readKeyframes","this","current","i","length","keyframe","trim","isCSSVariableToken","resolved","getVariableValue","undefined","finalKeyframe","resolveNoneKeyframes","positionalKeys","has","origin","target","originType","findDimensionValueType","targetType","isNumOrPxType","value","parseFloat","needsMeasurement","noneKeyframeIndexes","isNone","push","makeNoneKeyframesAnimatable","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","positionalValues","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","finalKeyframeIndex","removedTransforms","forEach","unsetTransformName","unsetTransformValue","set"],"mappings":"0bASA,MAAMA,UAA6BC,EAAAA,iBAC/BC,WAAAA,CAAYC,EAAqBC,EAAYC,EAAMC,EAAaC,GAC5DC,MAAML,EAAqBC,EAAYC,EAAMC,EAAaC,GAAS,EACvE,CACAE,aAAAA,GACI,MAAMN,oBAAEA,EAAmBI,QAAEA,EAAOF,KAAEA,GAASK,KAC/C,IAAKH,IAAYA,EAAQI,QACrB,OACJH,MAAMC,gBAIN,IAAK,IAAIG,EAAI,EAAGA,EAAIT,EAAoBU,OAAQD,IAAK,CACjD,IAAIE,EAAWX,EAAoBS,GACnC,GAAwB,iBAAbE,IACPA,EAAWA,EAASC,OAChBC,EAAAA,mBAAmBF,IAAW,CAC9B,MAAMG,EAAWC,EAAgBA,iBAACJ,EAAUP,EAAQI,cACnCQ,IAAbF,IACAd,EAAoBS,GAAKK,GAEzBL,IAAMT,EAAoBU,OAAS,IACnCH,KAAKU,cAAgBN,EAE7B,CAER,CAaA,GAPAJ,KAAKW,wBAOAC,EAAcA,eAACC,IAAIlB,IAAwC,IAA/BF,EAAoBU,OACjD,OAEJ,MAAOW,EAAQC,GAAUtB,EACnBuB,EAAaC,yBAAuBH,GACpCI,EAAaD,yBAAuBF,GAI1C,GAAIC,IAAeE,EAMnB,GAAIC,EAAaA,cAACH,IAAeG,EAAaA,cAACD,GAC3C,IAAK,IAAIhB,EAAI,EAAGA,EAAIT,EAAoBU,OAAQD,IAAK,CACjD,MAAMkB,EAAQ3B,EAAoBS,GACb,iBAAVkB,IACP3B,EAAoBS,GAAKmB,WAAWD,GAE5C,MAMApB,KAAKsB,kBAAmB,CAEhC,CACAX,oBAAAA,GACI,MAAMlB,oBAAEA,EAAmBE,KAAEA,GAASK,KAChCuB,EAAsB,GAC5B,IAAK,IAAIrB,EAAI,EAAGA,EAAIT,EAAoBU,OAAQD,KACb,OAA3BT,EAAoBS,IACpBsB,EAAAA,OAAO/B,EAAoBS,MAC3BqB,EAAoBE,KAAKvB,GAG7BqB,EAAoBpB,QACpBuB,EAAAA,4BAA4BjC,EAAqB8B,EAAqB5B,EAE9E,CACAgC,mBAAAA,GACI,MAAM9B,QAAEA,EAAOJ,oBAAEA,EAAmBE,KAAEA,GAASK,KAC/C,IAAKH,IAAYA,EAAQI,QACrB,OACS,WAATN,IACAK,KAAK4B,iBAAmBC,OAAOC,aAEnC9B,KAAK+B,eAAiBC,mBAAiBrC,GAAME,EAAQoC,qBAAsBJ,OAAOK,iBAAiBrC,EAAQI,UAC3GR,EAAoB,GAAKO,KAAK+B,eAE9B,MAAMI,EAAkB1C,EAAoBA,EAAoBU,OAAS,QACjDM,IAApB0B,GACAtC,EAAQuC,SAASzC,EAAMwC,GAAiBE,KAAKF,GAAiB,EAEtE,CACAG,eAAAA,GACI,MAAMzC,QAAEA,EAAOF,KAAEA,EAAIF,oBAAEA,GAAwBO,KAC/C,IAAKH,IAAYA,EAAQI,QACrB,OACJ,MAAMmB,EAAQvB,EAAQuC,SAASzC,GAC/ByB,GAASA,EAAMiB,KAAKrC,KAAK+B,gBAAgB,GACzC,MAAMQ,EAAqB9C,EAAoBU,OAAS,EAClDO,EAAgBjB,EAAoB8C,GAC1C9C,EAAoB8C,GAAsBP,mBAAiBrC,GAAME,EAAQoC,qBAAsBJ,OAAOK,iBAAiBrC,EAAQI,UACzG,OAAlBS,QAAiDD,IAAvBT,KAAKU,gBAC/BV,KAAKU,cAAgBA,GAGrBV,KAAKwC,mBAAmBrC,QACxBH,KAAKwC,kBAAkBC,SAAQ,EAAEC,EAAoBC,MACjD9C,EACKuC,SAASM,GACTE,IAAID,EAAoB,IAGrC3C,KAAKW,sBACT"}