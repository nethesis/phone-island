"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./utils/fill-wildcards.mjs.js"),s=require("./utils/unit-conversion.mjs.js"),t=require("../../frameloop/frame.mjs.js");const r=new Set;let i=!1,l=!1,o=!1;function a(){if(l){const e=Array.from(r).filter((e=>e.needsMeasurement)),t=new Set(e.map((e=>e.element))),i=new Map;t.forEach((e=>{const t=s.removeNonTranslationalTransform(e);t.length&&(i.set(e,t),e.render())})),e.forEach((e=>e.measureInitialState())),t.forEach((e=>{e.render();const s=i.get(e);s&&s.forEach((([s,t])=>{e.getValue(s)?.set(t)}))})),e.forEach((e=>e.measureEndState())),e.forEach((e=>{void 0!==e.suspendedScrollY&&window.scrollTo(0,e.suspendedScrollY)}))}l=!1,i=!1,r.forEach((e=>e.complete(o))),r.clear()}function n(){r.forEach((e=>{e.readKeyframes(),e.needsMeasurement&&(l=!0)}))}exports.KeyframeResolver=class{constructor(e,s,t,r,i,l=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...e],this.onComplete=s,this.name=t,this.motionValue=r,this.element=i,this.isAsync=l}scheduleResolve(){this.isScheduled=!0,this.isAsync?(r.add(this),i||(i=!0,t.frame.read(n),t.frame.resolveKeyframes(a))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:s,name:t,element:r,motionValue:i}=this;if(null===s[0]){const e=i?.get(),l=s[s.length-1];if(void 0!==e)s[0]=e;else if(r&&t){const e=r.readValue(t,l);null!=e&&(s[0]=e)}void 0===s[0]&&(s[0]=l),i&&void 0===e&&i.set(s[0])}e.fillWildcards(s)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(e=!1){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,e),r.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,r.delete(this))}resume(){this.isComplete||this.scheduleResolve()}},exports.flushKeyframeResolvers=function(){o=!0,n(),a(),o=!1};
//# sourceMappingURL=KeyframesResolver.mjs.js.map
