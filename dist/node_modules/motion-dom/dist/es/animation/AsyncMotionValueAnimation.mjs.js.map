{"version":3,"file":"AsyncMotionValueAnimation.mjs.js","sources":["../../../../../../node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs"],"sourcesContent":["import { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", keyframes, name, motionValue, element, ...options }) {\n        super();\n        /**\n         * Bound to support return animation.stop pattern\n         */\n        this.stop = () => {\n            if (this._animation) {\n                this._animation.stop();\n                this.stopTimeline?.();\n            }\n            else {\n                this.keyframeResolver?.cancel();\n            }\n        };\n        this.createdAt = time.now();\n        const optionsWithDefaults = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        };\n        const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n        this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n        this.keyframeResolver?.scheduleResolve();\n    }\n    onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n        this.keyframeResolver = undefined;\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options;\n        this.resolvedAt = time.now();\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n            }\n            keyframes[0] = keyframes[keyframes.length - 1];\n            options.duration = 0;\n            options.repeat = 0;\n        }\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first commited frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                    ? this.resolvedAt\n                    : this.createdAt\n            : undefined;\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        };\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n            ? new NativeAnimationExtended({\n                ...resolvedOptions,\n                element: resolvedOptions.motionValue.owner.current,\n            })\n            : new JSAnimation(resolvedOptions);\n        animation.finished.then(() => this.notifyFinished()).catch(noop);\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        this._animation = animation;\n    }\n    get finished() {\n        if (!this._animation) {\n            return this._finished;\n        }\n        else {\n            return this.animation.finished;\n        }\n    }\n    then(onResolve, _onReject) {\n        return this.finished.finally(onResolve).then(() => { });\n    }\n    get animation() {\n        if (!this._animation) {\n            flushKeyframeResolvers();\n        }\n        return this._animation;\n    }\n    get duration() {\n        return this.animation.duration;\n    }\n    get time() {\n        return this.animation.time;\n    }\n    set time(newTime) {\n        this.animation.time = newTime;\n    }\n    get speed() {\n        return this.animation.speed;\n    }\n    get state() {\n        return this.animation.state;\n    }\n    set speed(newSpeed) {\n        this.animation.speed = newSpeed;\n    }\n    get startTime() {\n        return this.animation.startTime;\n    }\n    attachTimeline(timeline) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline);\n        }\n        else {\n            this.pendingTimeline = timeline;\n        }\n        return () => this.stop();\n    }\n    play() {\n        this.animation.play();\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.complete();\n    }\n    cancel() {\n        this.animation.cancel();\n    }\n}\n\nexport { AsyncMotionValueAnimation };\n"],"names":["AsyncMotionValueAnimation","WithPromise","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","keyframes","name","motionValue","element","options","super","this","stop","_animation","stopTimeline","keyframeResolver","cancel","createdAt","time","now","optionsWithDefaults","KeyframeResolver$1","KeyframeResolver","resolvedKeyframes","finalKeyframe","forced","onKeyframesResolved","scheduleResolve","sync","undefined","velocity","isHandoff","onUpdate","resolvedAt","canAnimate","MotionGlobalConfig","instantAnimations","getFinalKeyframe","length","duration","resolvedOptions","startTime","animation","supportsBrowserAnimation","NativeAnimationExtended","owner","current","JSAnimation","finished","then","notifyFinished","catch","noop","pendingTimeline","attachTimeline","_finished","onResolve","_onReject","finally","flushKeyframeResolvers","newTime","speed","state","newSpeed","timeline","play","pause","complete"],"mappings":"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"}