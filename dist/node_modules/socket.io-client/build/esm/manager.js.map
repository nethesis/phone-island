{"version":3,"file":"manager.js","sources":["../../../../../node_modules/socket.io-client/build/esm/manager.js"],"sourcesContent":["import { Socket as Engine, installTimerFunctions, nextTick, } from \"engine.io-client\";\nimport { Socket } from \"./socket.js\";\nimport * as parser from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Backoff } from \"./contrib/backo2.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\nexport class Manager extends Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new Engine(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        const onError = (err) => {\n            this.cleanup();\n            this._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                this.maybeReconnectOnOpen();\n            }\n        };\n        // emit `error`\n        const errorSub = on(socket, \"error\", onError);\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                onError(new Error(\"timeout\"));\n                socket.close();\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        nextTick(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n"],"names":["Manager","Emitter","constructor","uri","opts","_a","super","this","nsps","subs","undefined","path","installTimerFunctions","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","Backoff","min","max","jitter","timeout","_readyState","_parser","parser","encoder","Encoder","decoder","Decoder","_autoConnect","autoConnect","open","v","arguments","length","_reconnection","_reconnectionAttempts","_reconnectionDelay","setMin","_randomizationFactor","setJitter","_reconnectionDelayMax","setMax","_timeout","maybeReconnectOnOpen","_reconnecting","attempts","reconnect","fn","indexOf","engine","Engine","Socket","socket","self","skipReconnect","openSubDestroy","on","onopen","onError","err","cleanup","emitReserved","errorSub","timer","setTimeoutFn","Error","close","autoUnref","unref","push","clearTimeoutFn","connect","onping","bind","ondata","onerror","onclose","ondecoded","data","add","e","packet","nextTick","nsp","active","_destroy","Object","keys","_close","_packet","encodedPackets","encode","i","write","options","forEach","subDestroy","destroy","disconnect","reason","description","reset","delay","duration","onreconnect","attempt"],"mappings":"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"}