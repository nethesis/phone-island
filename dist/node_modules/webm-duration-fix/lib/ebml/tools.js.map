{"version":3,"file":"tools.js","sources":["../../../../../node_modules/webm-duration-fix/lib/ebml/tools.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertEBMLDateToJSDate = exports.createFloatBuffer = exports.createIntBuffer = exports.createUIntBuffer = exports.encodeValueToBuffer = exports.concat = exports.putRefinedMetaData = exports.extractElement = exports.removeElement = exports.makeMetadataSeekable = exports.createRIFFChunk = exports.VP8BitStreamToRiffWebPBuffer = exports.WebPBlockFilter = exports.encodeTag = exports.readBlock = exports.ebmlBlock = exports.writeVint = exports.readVint = exports.Buffer = void 0;\n/// <reference types=\"node\"/>\nvar int64_buffer_1 = require(\"int64-buffer\");\nvar EBMLEncoder_1 = require(\"./EBMLEncoder\");\nvar _Buffer = require(\"buffer\");\nvar tools_ebml_1 = require(\"./tools-ebml\");\nvar _block = require(\"ebml-block\");\nexports.Buffer = _Buffer.Buffer;\nexports.readVint = tools_ebml_1.default.readVint;\nexports.writeVint = tools_ebml_1.default.writeVint;\nexports.ebmlBlock = _block;\nfunction readBlock(buf) {\n    return (0, exports.ebmlBlock)(new exports.Buffer(buf));\n}\nexports.readBlock = readBlock;\n/**\n  * @param end - if end === false then length is unknown\n  */\nfunction encodeTag(tagId, tagData, unknownSize) {\n    if (unknownSize === void 0) { unknownSize = false; }\n    return concat([\n        tagId,\n        unknownSize ?\n            new exports.Buffer('01ffffffffffffff', 'hex') :\n            (0, exports.writeVint)(tagData.length),\n        tagData\n    ]);\n}\nexports.encodeTag = encodeTag;\n/**\n * WebP ファイルにできる SimpleBlock の パスフィルタ\n */\nfunction WebPBlockFilter(elms) {\n    return elms.reduce(function (lst, elm) {\n        if (elm.type !== \"b\") {\n            return lst;\n        }\n        if (elm.name !== \"SimpleBlock\") {\n            return lst;\n        }\n        var o = (0, exports.ebmlBlock)(elm.data);\n        var hasWebP = o.frames.some(function (frame) {\n            // https://tools.ietf.org/html/rfc6386#section-19.1\n            var startcode = frame.slice(3, 6).toString(\"hex\");\n            return startcode === \"9d012a\";\n        });\n        if (!hasWebP) {\n            return lst;\n        }\n        return lst.concat(elm);\n    }, []);\n}\nexports.WebPBlockFilter = WebPBlockFilter;\n/**\n * @param frame - VP8 BitStream のうち startcode をもつ frame\n * @return - WebP ファイルの ArrayBuffer\n */\nfunction VP8BitStreamToRiffWebPBuffer(frame) {\n    var VP8Chunk = createRIFFChunk(\"VP8 \", frame);\n    var WebPChunk = concat([\n        new exports.Buffer(\"WEBP\", \"ascii\"),\n        VP8Chunk\n    ]);\n    return createRIFFChunk(\"RIFF\", WebPChunk);\n}\nexports.VP8BitStreamToRiffWebPBuffer = VP8BitStreamToRiffWebPBuffer;\n/**\n * RIFF データチャンクを作る\n */\nfunction createRIFFChunk(FourCC, chunk) {\n    var chunkSize = new exports.Buffer(4);\n    chunkSize.writeUInt32LE(chunk.byteLength, 0);\n    return concat([\n        new exports.Buffer(FourCC.substr(0, 4), \"ascii\"),\n        chunkSize,\n        chunk,\n        new exports.Buffer(chunk.byteLength % 2 === 0 ? 0 : 1) // padding\n    ]);\n}\nexports.createRIFFChunk = createRIFFChunk;\n/* Original Metadata\n\n m  0\tEBML\n u  1\t  EBMLVersion 1\n u  1\t  EBMLReadVersion 1\n u  1\t  EBMLMaxIDLength 4\n u  1\t  EBMLMaxSizeLength 8\n s  1\t  DocType webm\n u  1\t  DocTypeVersion 4\n u  1\t  DocTypeReadVersion 2\n m  0\tSegment\n m  1\t  Info                                segmentContentStartPos, all CueClusterPositions provided in info.cues will be relative to here and will need adjusted\n u  2\t    TimecodeScale 1000000\n 8  2\t    MuxingApp Chrome\n 8  2\t    WritingApp Chrome\n m  1\t  Tracks                              tracksStartPos\n m  2\t    TrackEntry\n u  3\t      TrackNumber 1\n u  3\t      TrackUID 31790271978391090\n u  3\t      TrackType 2\n s  3\t      CodecID A_OPUS\n b  3\t      CodecPrivate <Buffer 19>\n m  3\t      Audio\n f  4\t        SamplingFrequency 48000\n u  4\t        Channels 1\n m  2\t    TrackEntry\n u  3\t      TrackNumber 2\n u  3\t      TrackUID 24051277436254136\n u  3\t      TrackType 1\n s  3\t      CodecID V_VP8\n m  3\t      Video\n u  4\t        PixelWidth 1024\n u  4\t        PixelHeight 576\n m  1\t  Cluster                             clusterStartPos\n u  2\t    Timecode 0\n b  2\t    SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/* Desired Metadata\n\n m\t0 EBML\n u\t1   EBMLVersion 1\n u\t1   EBMLReadVersion 1\n u\t1   EBMLMaxIDLength 4\n u\t1   EBMLMaxSizeLength 8\n s\t1   DocType webm\n u\t1   DocTypeVersion 4\n u\t1   DocTypeReadVersion 2\n m\t0 Segment\n m\t1   SeekHead                            -> This is SeekPosition 0, so all SeekPositions can be calculated as (bytePos - segmentContentStartPos), which is 44 in this case\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x15, 0x49, 0xA9, 0x66])  Info\n u\t3       SeekPosition                    -> infoStartPos =\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x16, 0x54, 0xAE, 0x6B])  Tracks\n u\t3       SeekPosition { tracksStartPos }\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x1C, 0x53, 0xBB, 0x6B])  Cues\n u\t3       SeekPosition { cuesStartPos }\n m\t1   Info\n f\t2     Duration 32480                    -> overwrite, or insert if it doesn't exist\n u\t2     TimecodeScale 1000000\n 8\t2     MuxingApp Chrome\n 8\t2     WritingApp Chrome\n m\t1   Tracks\n m\t2     TrackEntry\n u\t3       TrackNumber 1\n u\t3       TrackUID 31790271978391090\n u\t3       TrackType 2\n s\t3       CodecID A_OPUS\n b\t3       CodecPrivate <Buffer 19>\n m\t3       Audio\n f\t4         SamplingFrequency 48000\n u\t4         Channels 1\n m\t2     TrackEntry\n u\t3       TrackNumber 2\n u\t3       TrackUID 24051277436254136\n u\t3       TrackType 1\n s\t3       CodecID V_VP8\n m\t3       Video\n u\t4         PixelWidth 1024\n u\t4         PixelHeight 576\n m  1   Cues                                -> cuesStartPos\n m  2     CuePoint\n u  3       CueTime 0\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  2     CuePoint\n u  3       CueTime 600\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  1   Cluster\n u  2     Timecode 0\n b  2     SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/**\n * convert the metadata from a streaming webm bytestream to a seekable file by inserting Duration, Seekhead and Cues\n * @param originalMetadata - orginal metadata (everything before the clusters start) from media recorder\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n */\nfunction makeMetadataSeekable(originalMetadata, duration, cuesInfo) {\n    // extract the header, we can reuse this as-is\n    var header = extractElement(\"EBML\", originalMetadata);\n    var headerSize = encodedSizeOfEbml(header);\n    //console.error(\"Header size: \" + headerSize);\n    //printElementIds(header);\n    // After the header comes the Segment open tag, which in this implementation is always 12 bytes (4 byte id, 8 byte 'unknown length')\n    // After that the segment content starts. All SeekPositions and CueClusterPosition must be relative to segmentContentStartPos\n    var segmentContentStartPos = headerSize + 12;\n    //console.error(\"segmentContentStartPos: \" + segmentContentStartPos);    \n    // find the original metadata size, and adjust it for header size and Segment start element so we can keep all positions relative to segmentContentStartPos\n    var originalMetadataSize = originalMetadata[originalMetadata.length - 1].dataEnd - segmentContentStartPos;\n    //console.error(\"Original Metadata size: \" + originalMetadataSize);\n    //printElementIds(originalMetadata);\n    // extract the segment info, remove the potentially existing Duration element, and add our own one.\n    var info = extractElement(\"Info\", originalMetadata);\n    removeElement(\"Duration\", info);\n    info.splice(1, 0, { name: \"Duration\", type: \"f\", data: createFloatBuffer(duration, 8) });\n    var infoSize = encodedSizeOfEbml(info);\n    //console.error(\"Info size: \" + infoSize);\n    //printElementIds(info);  \n    // extract the track info, we can re-use this as is\n    var tracks = extractElement(\"Tracks\", originalMetadata);\n    var tracksSize = encodedSizeOfEbml(tracks);\n    //console.error(\"Tracks size: \" + tracksSize);\n    //printElementIds(tracks);  \n    var seekHeadSize = 47; // Initial best guess, but could be slightly larger if the Cues element is huge.\n    var seekHead = [];\n    var cuesSize = 5 + cuesInfo.length * 15; // very rough initial approximation, depends a lot on file size and number of CuePoints                   \n    var cues = [];\n    var lastSizeDifference = -1; // \n    // The size of SeekHead and Cues elements depends on how many bytes the offsets values can be encoded in.\n    // The actual offsets in CueClusterPosition depend on the final size of the SeekHead and Cues elements\n    // We need to iteratively converge to a stable solution.\n    var maxIterations = 10;\n    var _loop_1 = function (i) {\n        // SeekHead starts at 0\n        var infoStart = seekHeadSize; // Info comes directly after SeekHead\n        var tracksStart = infoStart + infoSize; // Tracks comes directly after Info\n        var cuesStart = tracksStart + tracksSize; // Cues starts directly after \n        var newMetadataSize = cuesStart + cuesSize; // total size of metadata  \n        // This is the offset all CueClusterPositions should be adjusted by due to the metadata size changing.\n        var sizeDifference = newMetadataSize - originalMetadataSize;\n        // console.error(`infoStart: ${infoStart}, infoSize: ${infoSize}`);\n        // console.error(`tracksStart: ${tracksStart}, tracksSize: ${tracksSize}`);\n        // console.error(`cuesStart: ${cuesStart}, cuesSize: ${cuesSize}`);\n        // console.error(`originalMetadataSize: ${originalMetadataSize}, newMetadataSize: ${newMetadataSize}, sizeDifference: ${sizeDifference}`); \n        // create the SeekHead element\n        seekHead = [];\n        seekHead.push({ name: \"SeekHead\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) }); // Info\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(infoStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) }); // Tracks\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(tracksStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) }); // Cues\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(cuesStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"SeekHead\", type: \"m\", isEnd: true });\n        seekHeadSize = encodedSizeOfEbml(seekHead);\n        //console.error(\"SeekHead size: \" + seekHeadSize);\n        //printElementIds(seekHead);  \n        // create the Cues element\n        cues = [];\n        cues.push({ name: \"Cues\", type: \"m\", isEnd: false });\n        cuesInfo.forEach(function (_a) {\n            var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n            cues.push({ name: \"CuePoint\", type: \"m\", isEnd: false });\n            cues.push({ name: \"CueTime\", type: \"u\", data: createUIntBuffer(CueTime) });\n            cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: false });\n            cues.push({ name: \"CueTrack\", type: \"u\", data: createUIntBuffer(CueTrack) });\n            //console.error(`CueClusterPosition: ${CueClusterPosition}, Corrected to: ${CueClusterPosition - segmentContentStartPos}  , offset by ${sizeDifference} to become ${(CueClusterPosition - segmentContentStartPos) + sizeDifference - segmentContentStartPos}`);\n            // EBMLReader returns CueClusterPosition with absolute byte offsets. The Cues section expects them as offsets from the first level 1 element of the Segment, so we need to adjust it.\n            CueClusterPosition -= segmentContentStartPos;\n            // We also need to adjust to take into account the change in metadata size from when EBMLReader read the original metadata.\n            CueClusterPosition += sizeDifference;\n            cues.push({ name: \"CueClusterPosition\", type: \"u\", data: createUIntBuffer(CueClusterPosition) });\n            cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: true });\n            cues.push({ name: \"CuePoint\", type: \"m\", isEnd: true });\n        });\n        cues.push({ name: \"Cues\", type: \"m\", isEnd: true });\n        cuesSize = encodedSizeOfEbml(cues);\n        //console.error(\"Cues size: \" + cuesSize);   \n        //console.error(\"Cue count: \" + cuesInfo.length);\n        //printElementIds(cues);      \n        // If the new MetadataSize is not the same as the previous iteration, we need to run once more.\n        if (lastSizeDifference !== sizeDifference) {\n            lastSizeDifference = sizeDifference;\n            if (i === maxIterations - 1) {\n                throw new Error(\"Failed to converge to a stable metadata size\");\n            }\n        }\n        else {\n            return \"break\";\n        }\n    };\n    for (var i = 0; i < maxIterations; i++) {\n        var state_1 = _loop_1(i);\n        if (state_1 === \"break\")\n            break;\n    }\n    var finalMetadata = [].concat.apply([], [\n        header,\n        { name: \"Segment\", type: \"m\", isEnd: false, unknownSize: true },\n        seekHead,\n        info,\n        tracks,\n        cues\n    ]);\n    var result = new EBMLEncoder_1.default().encode(finalMetadata);\n    //printElementIds(finalMetadata);\n    //console.error(`Final metadata buffer size: ${result.byteLength}`);\n    //console.error(`Final metadata buffer size without header and segment: ${result.byteLength-segmentContentStartPos}`);\n    return result;\n}\nexports.makeMetadataSeekable = makeMetadataSeekable;\n/**\n * print all element id names in a list\n\n * @param metadata - array of EBML elements to print\n *\nexport function printElementIds(metadata: EBML.EBMLElementBuffer[]) {\n\n  let result: EBML.EBMLElementBuffer[] = [];\n  let start: number = -1;\n\n  for (let i = 0; i < metadata.length; i++) {\n    console.error(\"\\t id: \" + metadata[i].name);\n  }\n}\n*/\n/**\n * remove all occurances of an EBML element from an array of elements\n * If it's a MasterElement you will also remove the content. (everything between start and end)\n * @param idName - name of the EBML Element to remove.\n * @param metadata - array of EBML elements to search\n */\nfunction removeElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it's a Master element, extract the start and end element, and everything in between\n            if (element.type === \"m\") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we've reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error(\"Detected \".concat(idName, \" closing element before finding the start\"));\n                    metadata.splice(start, i - start + 1);\n                    return;\n                }\n            }\n            else {\n                // not a Master element, so we've found what we're looking for.\n                metadata.splice(i, 1);\n                return;\n            }\n        }\n    }\n}\nexports.removeElement = removeElement;\n/**\n * extract the first occurance of an EBML tag from a flattened array of EBML data.\n * If it's a MasterElement you will also get the content. (everything between start and end)\n * @param idName - name of the EBML Element to extract.\n * @param metadata - array of EBML elements to search\n */\nfunction extractElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it's a Master element, extract the start and end element, and everything in between\n            if (element.type === \"m\") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we've reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error(\"Detected \".concat(idName, \" closing element before finding the start\"));\n                    result = metadata.slice(start, i + 1);\n                    break;\n                }\n            }\n            else {\n                // not a Master element, so we've found what we're looking for.\n                result.push(metadata[i]);\n                break;\n            }\n        }\n    }\n    return result;\n}\nexports.extractElement = extractElement;\n/**\n * @deprecated\n * metadata に対して duration と seekhead を追加した metadata を返す\n * @param metadata - 変更前の webm における ファイル先頭から 最初の Cluster 要素までの 要素\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n * @deprecated @param clusterPtrs - 変更前の webm における SeekHead に追加する Cluster 要素 への start pointer\n * @deprecated @param cueInfos - please use cues.\n */\nfunction putRefinedMetaData(metadata, info) {\n    if (Array.isArray(info.cueInfos) && !Array.isArray(info.cues)) {\n        console.warn(\"putRefinedMetaData: info.cueInfos property is deprecated. please use info.cues\");\n        info.cues = info.cueInfos;\n    }\n    var ebml = [];\n    var payload = [];\n    for (var i_1 = 0; i_1 < metadata.length; i_1++) {\n        var elm = metadata[i_1];\n        if (elm.type === \"m\" && elm.name === \"Segment\") {\n            ebml = metadata.slice(0, i_1);\n            payload = metadata.slice(i_1);\n            if (elm.unknownSize) {\n                payload.shift(); // remove segment tag\n                break;\n            }\n            throw new Error(\"this metadata is not streaming webm file\");\n        }\n    }\n    // *0    *4    *5  *36      *40   *48=segmentOffset              *185=originalPayloadOffsetEnd\n    // |     |     |   |        |     |                              |\n    // [EBML][size]....[Segment][size][Info][size][Duration][size]...[Cluster]\n    // |               |        |^inf |                              |\n    // |               +segmentSiz(12)+                              |\n    // +-ebmlSize(36)--+        |     +-payloadSize(137)-------------+offsetEndDiff+\n    //                 |        |     +-newPayloadSize(??)-------------------------+\n    //                 |        |     |                                            |\n    //                 [Segment][size][Info][size][Duration][size]....[size][value][Cluster]\n    //                           ^                                                 |\n    //                           |                                                 *??=newPayloadOffsetEnd\n    //                           inf\n    if (!(payload[payload.length - 1].dataEnd > 0)) {\n        throw new Error(\"metadata dataEnd has wrong number\");\n    }\n    var originalPayloadOffsetEnd = payload[payload.length - 1].dataEnd; // = first cluster ptr\n    var ebmlSize = ebml[ebml.length - 1].dataEnd; // = first segment ptr\n    var refinedEBMLSize = new EBMLEncoder_1.default().encode(ebml).byteLength;\n    var offsetDiff = refinedEBMLSize - ebmlSize;\n    var payloadSize = originalPayloadOffsetEnd - payload[0].tagStart;\n    var segmentSize = payload[0].tagStart - ebmlSize;\n    var segmentOffset = payload[0].tagStart;\n    var segmentTagBuf = new exports.Buffer([0x18, 0x53, 0x80, 0x67]); // Segment\n    var segmentSizeBuf = new exports.Buffer('01ffffffffffffff', 'hex'); // Segmentの最後の位置は無数の Cluster 依存なので。 writeVint(newPayloadSize).byteLength ではなく、 infinity.\n    var _segmentSize = segmentTagBuf.byteLength + segmentSizeBuf.byteLength; // == segmentSize\n    var newPayloadSize = payloadSize;\n    // We need the size to be stable between two refinements in order for our offsets to be correct\n    // Bound the number of possible refinements so we can't go infinate if something goes wrong\n    var i;\n    for (i = 1; i < 20; i++) {\n        var newPayloadOffsetEnd = ebmlSize + _segmentSize + newPayloadSize;\n        var offsetEndDiff = newPayloadOffsetEnd - originalPayloadOffsetEnd;\n        var sizeDiff = offsetDiff + offsetEndDiff;\n        var refined = refineMetadata(payload, sizeDiff, info);\n        var newNewRefinedSize = new EBMLEncoder_1.default().encode(refined).byteLength; // 一旦 seekhead を作って自身のサイズを調べる\n        if (newNewRefinedSize === newPayloadSize) {\n            // Size is stable\n            return new EBMLEncoder_1.default().encode([].concat(ebml, [{ type: \"m\", name: \"Segment\", isEnd: false, unknownSize: true }], refined));\n        }\n        newPayloadSize = newNewRefinedSize;\n    }\n    throw new Error(\"unable to refine metadata, stable size could not be found in \" + i + \" iterations!\");\n}\nexports.putRefinedMetaData = putRefinedMetaData;\n// Given a list of EBMLElementBuffers, returns their encoded size in bytes\nfunction encodedSizeOfEbml(refinedMetaData) {\n    var encorder = new EBMLEncoder_1.default();\n    return refinedMetaData.reduce(function (lst, elm) { return lst.concat(encorder.encode([elm])); }, []).reduce(function (o, buf) { return o + buf.byteLength; }, 0);\n}\nfunction refineMetadata(mesetadata, sizeDiff, info) {\n    var duration = info.duration, clusterPtrs = info.clusterPtrs, cues = info.cues;\n    var _metadata = mesetadata.slice(0);\n    if (typeof duration === \"number\") {\n        // duration を追加する\n        var overwrited_1 = false;\n        _metadata.forEach(function (elm) {\n            if (elm.type === \"f\" && elm.name === \"Duration\") {\n                overwrited_1 = true;\n                elm.data = createFloatBuffer(duration, 8);\n            }\n        });\n        if (!overwrited_1) {\n            insertTag(_metadata, \"Info\", [{ name: \"Duration\", type: \"f\", data: createFloatBuffer(duration, 8) }]);\n        }\n    }\n    if (Array.isArray(cues)) {\n        insertTag(_metadata, \"Cues\", create_cue(cues, sizeDiff));\n    }\n    var seekhead_children = [];\n    if (Array.isArray(clusterPtrs)) {\n        console.warn(\"append cluster pointers to seekhead is deprecated. please use cues\");\n        seekhead_children = create_seek_from_clusters(clusterPtrs, sizeDiff);\n    }\n    // remove seek info\n    /*\n    _metadata = _metadata.filter((elm)=> !(\n      elm.name === \"Seek\" ||\n      elm.name === \"SeekID\" ||\n      elm.name === \"SeekPosition\") );\n    */\n    // working on progress\n    //seekhead_children = seekhead_children.concat(create_seekhead(_metadata));\n    insertTag(_metadata, \"SeekHead\", seekhead_children, true);\n    return _metadata;\n}\nfunction create_seekhead(metadata, sizeDiff) {\n    var seeks = [];\n    [\"Info\", \"Tracks\", \"Cues\"].forEach(function (tagName) {\n        var tagStarts = metadata.filter(function (elm) { return elm.type === \"m\" && elm.name === tagName && elm.isEnd === false; }).map(function (elm) { return elm[\"tagStart\"]; });\n        var tagStart = tagStarts[0];\n        if (typeof tagStart !== \"number\") {\n            return;\n        }\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        switch (tagName) {\n            case \"Info\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) });\n                break;\n            case \"Tracks\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) });\n                break;\n            case \"Cues\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) });\n                break;\n        }\n        seeks.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(tagStart + sizeDiff) });\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_seek_from_clusters(clusterPtrs, sizeDiff) {\n    var seeks = [];\n    clusterPtrs.forEach(function (start) {\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        // [0x1F, 0x43, 0xB6, 0x75] で Cluster 意\n        seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1F, 0x43, 0xB6, 0x75]) });\n        seeks.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(start + sizeDiff) });\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_cue(cueInfos, sizeDiff) {\n    var cues = [];\n    cueInfos.forEach(function (_a) {\n        var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n        cues.push({ name: \"CuePoint\", type: \"m\", isEnd: false });\n        cues.push({ name: \"CueTime\", type: \"u\", data: createUIntBuffer(CueTime) });\n        cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: false });\n        cues.push({ name: \"CueTrack\", type: \"u\", data: createUIntBuffer(CueTrack) }); // video track\n        cues.push({ name: \"CueClusterPosition\", type: \"u\", data: createUIntBuffer(CueClusterPosition + sizeDiff) });\n        cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: true });\n        cues.push({ name: \"CuePoint\", type: \"m\", isEnd: true });\n    });\n    return cues;\n}\nfunction insertTag(_metadata, tagName, children, insertHead) {\n    if (insertHead === void 0) { insertHead = false; }\n    // find the tagname from _metadata\n    var idx = -1;\n    for (var i = 0; i < _metadata.length; i++) {\n        var elm = _metadata[i];\n        if (elm.type === \"m\" && elm.name === tagName && elm.isEnd === false) {\n            idx = i;\n            break;\n        }\n    }\n    if (idx >= 0) {\n        // insert [<CuePoint />] to <Cues />\n        Array.prototype.splice.apply(_metadata, [idx + 1, 0].concat(children));\n    }\n    else if (insertHead) {\n        [].concat([{ name: tagName, type: \"m\", isEnd: false }], children, [{ name: tagName, type: \"m\", isEnd: true }]).reverse().forEach(function (elm) { _metadata.unshift(elm); });\n    }\n    else {\n        // metadata 末尾に <Cues /> を追加\n        // insert <Cues />\n        _metadata.push({ name: tagName, type: \"m\", isEnd: false });\n        children.forEach(function (elm) { _metadata.push(elm); });\n        _metadata.push({ name: tagName, type: \"m\", isEnd: true });\n    }\n}\nfunction concat(list) {\n    return exports.Buffer.concat(list);\n}\nexports.concat = concat;\nfunction encodeValueToBuffer(elm) {\n    var data = new exports.Buffer(0);\n    if (elm.type === \"m\") {\n        return elm;\n    }\n    switch (elm.type) {\n        case \"u\":\n            data = createUIntBuffer(elm.value);\n            break;\n        case \"i\":\n            data = createIntBuffer(elm.value);\n            break;\n        case \"f\":\n            data = createFloatBuffer(elm.value);\n            break;\n        case \"s\":\n            data = new exports.Buffer(elm.value, 'ascii');\n            break;\n        case \"8\":\n            data = new exports.Buffer(elm.value, 'utf8');\n            break;\n        case \"b\":\n            data = elm.value;\n            break;\n        case \"d\":\n            data = new int64_buffer_1.Int64BE(elm.value.getTime().toString()).toBuffer();\n            break;\n    }\n    return Object.assign({}, elm, { data: data });\n}\nexports.encodeValueToBuffer = encodeValueToBuffer;\nfunction createUIntBuffer(value) {\n    // Big-endian, any size from 1 to 8\n    // but js number is float64, so max 6 bit octets\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn(\"7bit or more bigger uint not supported.\");\n        return new int64_buffer_1.Uint64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeUIntBE(value, 0, bytes);\n    return data;\n}\nexports.createUIntBuffer = createUIntBuffer;\nfunction createIntBuffer(value) {\n    // Big-endian, any size from 1 to 8 octets\n    // but js number is float64, so max 6 bit\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn(\"7bit or more bigger uint not supported.\");\n        return new int64_buffer_1.Int64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeIntBE(value, 0, bytes);\n    return data;\n}\nexports.createIntBuffer = createIntBuffer;\nfunction createFloatBuffer(value, bytes) {\n    if (bytes === void 0) { bytes = 8; }\n    // Big-endian, defined for 4 and 8 octets (32, 64 bits)\n    // js number is float64 so 8 bytes.\n    if (bytes === 8) {\n        // 64bit\n        var data = new exports.Buffer(8);\n        data.writeDoubleBE(value, 0);\n        return data;\n    }\n    else if (bytes === 4) {\n        // 32bit\n        var data = new exports.Buffer(4);\n        data.writeFloatBE(value, 0);\n        return data;\n    }\n    else {\n        throw new Error(\"float type bits must 4bytes or 8bytes\");\n    }\n}\nexports.createFloatBuffer = createFloatBuffer;\nfunction convertEBMLDateToJSDate(int64str) {\n    if (int64str instanceof Date) {\n        return int64str;\n    }\n    return new Date(new Date(\"2001-01-01T00:00:00.000Z\").getTime() + (Number(int64str) / 1000 / 1000));\n}\nexports.convertEBMLDateToJSDate = convertEBMLDateToJSDate;\n"],"names":["Object","defineProperty","exports","value","convertEBMLDateToJSDate","createFloatBuffer","createUIntBuffer","encodeValueToBuffer","putRefinedMetaData","extractElement","makeMetadataSeekable","createRIFFChunk","WebPBlockFilter","encodeTag","ebmlBlock","writeVint","Buffer","int64_buffer_1","require$$0","EBMLEncoder_1","require$$1","_Buffer","require$$2","tools_ebml_1","require$$3","_block","require$$4","FourCC","chunk","chunkSize","writeUInt32LE","byteLength","concat","substr","removeElement","idName","metadata","start","i","length","element","name","type","splice","isEnd","Error","result","push","slice","encodedSizeOfEbml","refinedMetaData","encorder","default","reduce","lst","elm","encode","o","buf","refineMetadata","mesetadata","sizeDiff","info","duration","clusterPtrs","cues","_metadata","overwrited_1","forEach","data","insertTag","Array","isArray","cueInfos","_a","CueTrack","CueClusterPosition","CueTime","create_cue","seekhead_children","console","warn","seeks","create_seek_from_clusters","tagName","children","insertHead","idx","prototype","apply","reverse","unshift","list","bytes","Math","pow","Uint64BE","toBuffer","writeUIntBE","createIntBuffer","Int64BE","writeIntBE","writeDoubleBE","writeFloatBE","readVint","readBlock","tagId","tagData","unknownSize","elms","frames","some","frame","toString","VP8BitStreamToRiffWebPBuffer","VP8Chunk","originalMetadata","cuesInfo","header","segmentContentStartPos","originalMetadataSize","dataEnd","infoSize","tracks","tracksSize","seekHeadSize","seekHead","cuesSize","lastSizeDifference","_loop_1","infoStart","tracksStart","cuesStart","sizeDifference","maxIterations","finalMetadata","ebml","payload","i_1","shift","originalPayloadOffsetEnd","ebmlSize","offsetDiff","payloadSize","tagStart","segmentTagBuf","segmentSizeBuf","_segmentSize","newPayloadSize","refined","newNewRefinedSize","getTime","assign","int64str","Date","Number"],"mappings":"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"}