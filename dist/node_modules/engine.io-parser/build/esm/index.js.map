{"version":3,"file":"index.js","sources":["../../../../../node_modules/engine.io-parser/build/esm/index.js"],"sourcesContent":["import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nimport { ERROR_PACKET, } from \"./commons.js\";\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        encodePacket(packet, false, (encodedPacket) => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nexport function createPacketEncoderStream() {\n    // @ts-expect-error\n    return new TransformStream({\n        transform(packet, controller) {\n            encodePacketToBinary(packet, (encodedPacket) => {\n                const payloadLength = encodedPacket.length;\n                let header;\n                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n                if (payloadLength < 126) {\n                    header = new Uint8Array(1);\n                    new DataView(header.buffer).setUint8(0, payloadLength);\n                }\n                else if (payloadLength < 65536) {\n                    header = new Uint8Array(3);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 126);\n                    view.setUint16(1, payloadLength);\n                }\n                else {\n                    header = new Uint8Array(9);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 127);\n                    view.setBigUint64(1, BigInt(payloadLength));\n                }\n                // first bit indicates whether the payload is plain text (0) or binary (1)\n                if (packet.data && typeof packet.data !== \"string\") {\n                    header[0] |= 0x80;\n                }\n                controller.enqueue(header);\n                controller.enqueue(encodedPacket);\n            });\n        },\n    });\n}\nlet TEXT_DECODER;\nfunction totalLength(chunks) {\n    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n}\nfunction concatChunks(chunks, size) {\n    if (chunks[0].length === size) {\n        return chunks.shift();\n    }\n    const buffer = new Uint8Array(size);\n    let j = 0;\n    for (let i = 0; i < size; i++) {\n        buffer[i] = chunks[0][j++];\n        if (j === chunks[0].length) {\n            chunks.shift();\n            j = 0;\n        }\n    }\n    if (chunks.length && j < chunks[0].length) {\n        chunks[0] = chunks[0].slice(j);\n    }\n    return buffer;\n}\nexport function createPacketDecoderStream(maxPayload, binaryType) {\n    if (!TEXT_DECODER) {\n        TEXT_DECODER = new TextDecoder();\n    }\n    const chunks = [];\n    let state = 0 /* READ_HEADER */;\n    let expectedLength = -1;\n    let isBinary = false;\n    // @ts-expect-error\n    return new TransformStream({\n        transform(chunk, controller) {\n            chunks.push(chunk);\n            while (true) {\n                if (state === 0 /* READ_HEADER */) {\n                    if (totalLength(chunks) < 1) {\n                        break;\n                    }\n                    const header = concatChunks(chunks, 1);\n                    isBinary = (header[0] & 0x80) === 0x80;\n                    expectedLength = header[0] & 0x7f;\n                    if (expectedLength < 126) {\n                        state = 3 /* READ_PAYLOAD */;\n                    }\n                    else if (expectedLength === 126) {\n                        state = 1 /* READ_EXTENDED_LENGTH_16 */;\n                    }\n                    else {\n                        state = 2 /* READ_EXTENDED_LENGTH_64 */;\n                    }\n                }\n                else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {\n                    if (totalLength(chunks) < 2) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 2);\n                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n                    state = 3 /* READ_PAYLOAD */;\n                }\n                else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {\n                    if (totalLength(chunks) < 8) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 8);\n                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\n                    const n = view.getUint32(0);\n                    if (n > Math.pow(2, 53 - 32) - 1) {\n                        // the maximum safe integer in JavaScript is 2^53 - 1\n                        controller.enqueue(ERROR_PACKET);\n                        break;\n                    }\n                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n                    state = 3 /* READ_PAYLOAD */;\n                }\n                else {\n                    if (totalLength(chunks) < expectedLength) {\n                        break;\n                    }\n                    const data = concatChunks(chunks, expectedLength);\n                    controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n                    state = 0 /* READ_HEADER */;\n                }\n                if (expectedLength === 0 || expectedLength > maxPayload) {\n                    controller.enqueue(ERROR_PACKET);\n                    break;\n                }\n            }\n        },\n    });\n}\nexport const protocol = 4;\nexport { encodePacket, encodePayload, decodePacket, decodePayload, };\n"],"names":["SEPARATOR","String","fromCharCode","TEXT_DECODER","totalLength","chunks","reduce","acc","chunk","length","concatChunks","size","shift","buffer","Uint8Array","j","i","slice","maxPayload","binaryType","TextDecoder","state","expectedLength","isBinary","TransformStream","transform","controller","push","header","headerArray","DataView","byteOffset","getUint16","view","n","getUint32","Math","pow","enqueue","ERROR_PACKET","data","decodePacket","decode","packet","encodePacketToBinary","encodedPacket","payloadLength","setUint8","setUint16","setBigUint64","BigInt","decodePayload","encodedPayload","encodedPackets","split","packets","decodedPacket","type","encodePayload","callback","Array","count","forEach","encodePacket","join"],"mappings":"gLAGA,MAAMA,EAAYC,OAAOC,aAAa,IA8DtC,IAAIC,EACJ,SAASC,EAAYC,GACjB,OAAOA,EAAOC,QAAO,CAACC,EAAKC,IAAUD,EAAMC,EAAMC,QAAQ,EAC7D,CACA,SAASC,EAAaL,EAAQM,GAC1B,GAAIN,EAAO,GAAGI,SAAWE,EACrB,OAAON,EAAOO,QAElB,MAAMC,EAAS,IAAIC,WAAWH,GAC9B,IAAII,EAAI,EACR,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAMK,IACtBH,EAAOG,GAAKX,EAAO,GAAGU,KAClBA,IAAMV,EAAO,GAAGI,SAChBJ,EAAOO,QACPG,EAAI,GAMZ,OAHIV,EAAOI,QAAUM,EAAIV,EAAO,GAAGI,SAC/BJ,EAAO,GAAKA,EAAO,GAAGY,MAAMF,IAEzBF,CACX,2GACO,SAAmCK,EAAYC,GAC7ChB,IACDA,EAAe,IAAIiB,aAEvB,MAAMf,EAAS,GACf,IAAIgB,EAAQ,EACRC,GAAkB,EAClBC,GAAW,EAEf,OAAO,IAAIC,gBAAgB,CACvBC,SAAAA,CAAUjB,EAAOkB,GAEb,IADArB,EAAOsB,KAAKnB,KACC,CACT,GAAc,IAAVa,EAA+B,CAC/B,GAAIjB,EAAYC,GAAU,EACtB,MAEJ,MAAMuB,EAASlB,EAAaL,EAAQ,GACpCkB,IAAkC,KAAtBK,EAAO,IACnBN,EAA6B,IAAZM,EAAO,GAEpBP,EADAC,EAAiB,IACT,EAEgB,MAAnBA,EACG,EAGA,CAEhB,MACK,GAAc,IAAVD,EAA2C,CAChD,GAAIjB,EAAYC,GAAU,EACtB,MAEJ,MAAMwB,EAAcnB,EAAaL,EAAQ,GACzCiB,EAAiB,IAAIQ,SAASD,EAAYhB,OAAQgB,EAAYE,WAAYF,EAAYpB,QAAQuB,UAAU,GACxGX,EAAQ,CACZ,MACK,GAAc,IAAVA,EAA2C,CAChD,GAAIjB,EAAYC,GAAU,EACtB,MAEJ,MAAMwB,EAAcnB,EAAaL,EAAQ,GACnC4B,EAAO,IAAIH,SAASD,EAAYhB,OAAQgB,EAAYE,WAAYF,EAAYpB,QAC5EyB,EAAID,EAAKE,UAAU,GACzB,GAAID,EAAIE,KAAKC,IAAI,EAAG,IAAW,EAAG,CAE9BX,EAAWY,QAAQC,EAAAA,cACnB,KACJ,CACAjB,EAAiBY,EAAIE,KAAKC,IAAI,EAAG,IAAMJ,EAAKE,UAAU,GACtDd,EAAQ,CACZ,KACK,CACD,GAAIjB,EAAYC,GAAUiB,EACtB,MAEJ,MAAMkB,EAAO9B,EAAaL,EAAQiB,GAClCI,EAAWY,QAAQG,eAAalB,EAAWiB,EAAOrC,EAAauC,OAAOF,GAAOrB,IAC7EE,EAAQ,CACZ,CACA,GAAuB,IAAnBC,GAAwBA,EAAiBJ,EAAY,CACrDQ,EAAWY,QAAQC,EAAAA,cACnB,KACJ,CACJ,CACJ,GAER,oCA5HO,WAEH,OAAO,IAAIf,gBAAgB,CACvBC,SAAAA,CAAUkB,EAAQjB,GACdkB,EAAoBA,qBAACD,GAASE,IAC1B,MAAMC,EAAgBD,EAAcpC,OACpC,IAAImB,EAEJ,GAAIkB,EAAgB,IAChBlB,EAAS,IAAId,WAAW,GACxB,IAAIgB,SAASF,EAAOf,QAAQkC,SAAS,EAAGD,QAEvC,GAAIA,EAAgB,MAAO,CAC5BlB,EAAS,IAAId,WAAW,GACxB,MAAMmB,EAAO,IAAIH,SAASF,EAAOf,QACjCoB,EAAKc,SAAS,EAAG,KACjBd,EAAKe,UAAU,EAAGF,EACtB,KACK,CACDlB,EAAS,IAAId,WAAW,GACxB,MAAMmB,EAAO,IAAIH,SAASF,EAAOf,QACjCoB,EAAKc,SAAS,EAAG,KACjBd,EAAKgB,aAAa,EAAGC,OAAOJ,GAChC,CAEIH,EAAOH,MAA+B,iBAAhBG,EAAOH,OAC7BZ,EAAO,IAAM,KAEjBF,EAAWY,QAAQV,GACnBF,EAAWY,QAAQO,EAAc,GAEzC,GAER,wBA7CsBM,CAACC,EAAgBjC,KACnC,MAAMkC,EAAiBD,EAAeE,MAAMtD,GACtCuD,EAAU,GAChB,IAAK,IAAIvC,EAAI,EAAGA,EAAIqC,EAAe5C,OAAQO,IAAK,CAC5C,MAAMwC,EAAgBf,EAAAA,aAAaY,EAAerC,GAAIG,GAEtD,GADAoC,EAAQ5B,KAAK6B,GACc,UAAvBA,EAAcC,KACd,KAER,CACA,OAAOF,CAAO,wBAzBIG,CAACH,EAASI,KAE5B,MAAMlD,EAAS8C,EAAQ9C,OACjB4C,EAAiB,IAAIO,MAAMnD,GACjC,IAAIoD,EAAQ,EACZN,EAAQO,SAAQ,CAACnB,EAAQ3B,KAErB+C,eAAapB,GAAQ,GAAQE,IACzBQ,EAAerC,GAAK6B,IACdgB,IAAUpD,GACZkD,EAASN,EAAeW,KAAKhE,GACjC,GACF,GACJ,mBA2IkB"}