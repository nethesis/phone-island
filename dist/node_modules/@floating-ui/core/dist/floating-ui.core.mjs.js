"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("../../utils/dist/floating-ui.utils.mjs.js");function t(t,n,i){let{reference:a,floating:l}=t;const o=e.getSideAxis(n),r=e.getAlignmentAxis(n),s=e.getAxisLength(r),c=e.getSide(n),f="y"===o,m=a.x+a.width/2-l.width/2,g=a.y+a.height/2-l.height/2,d=a[s]/2-l[s]/2;let u;switch(c){case"top":u={x:m,y:a.y-l.height};break;case"bottom":u={x:m,y:a.y+a.height};break;case"right":u={x:a.x+a.width,y:g};break;case"left":u={x:a.x-l.width,y:g};break;default:u={x:a.x,y:a.y}}switch(e.getAlignment(n)){case"start":u[r]-=d*(i&&f?-1:1);break;case"end":u[r]+=d*(i&&f?-1:1)}return u}async function n(t,n){var i;void 0===n&&(n={});const{x:a,y:l,platform:o,rects:r,elements:s,strategy:c}=t,{boundary:f="clippingAncestors",rootBoundary:m="viewport",elementContext:g="floating",altBoundary:d=!1,padding:u=0}=e.evaluate(n,t),p=e.getPaddingObject(u),x=s[d?"floating"===g?"reference":"floating":g],h=e.rectToClientRect(await o.getClippingRect({element:null==(i=await(null==o.isElement?void 0:o.isElement(x)))||i?x:x.contextElement||await(null==o.getDocumentElement?void 0:o.getDocumentElement(s.floating)),boundary:f,rootBoundary:m,strategy:c})),y="floating"===g?{...r.floating,x:a,y:l}:r.reference,w=await(null==o.getOffsetParent?void 0:o.getOffsetParent(s.floating)),v=await(null==o.isElement?void 0:o.isElement(w))&&await(null==o.getScale?void 0:o.getScale(w))||{x:1,y:1},A=e.rectToClientRect(o.convertOffsetParentRelativeRectToViewportRelativeRect?await o.convertOffsetParentRelativeRectToViewportRelativeRect({elements:s,rect:y,offsetParent:w,strategy:c}):y);return{top:(h.top-A.top+p.top)/v.y,bottom:(A.bottom-h.bottom+p.bottom)/v.y,left:(h.left-A.left+p.left)/v.x,right:(A.right-h.right+p.right)/v.x}}function i(e,t){return{top:e.top-t.height,right:e.right-t.width,bottom:e.bottom-t.height,left:e.left-t.width}}function a(t){return e.sides.some((e=>t[e]>=0))}function l(t){const n=e.min(...t.map((e=>e.left))),i=e.min(...t.map((e=>e.top)));return{x:n,y:i,width:e.max(...t.map((e=>e.right)))-n,height:e.max(...t.map((e=>e.bottom)))-i}}exports.rectToClientRect=e.rectToClientRect,exports.arrow=t=>({name:"arrow",options:t,async fn(n){const{x:i,y:a,placement:l,rects:o,platform:r,elements:s,middlewareData:c}=n,{element:f,padding:m=0}=e.evaluate(t,n)||{};if(null==f)return{};const g=e.getPaddingObject(m),d={x:i,y:a},u=e.getAlignmentAxis(l),p=e.getAxisLength(u),x=await r.getDimensions(f),h="y"===u,y=h?"top":"left",w=h?"bottom":"right",v=h?"clientHeight":"clientWidth",A=o.reference[p]+o.reference[u]-d[u]-o.floating[p],b=d[u]-o.reference[u],R=await(null==r.getOffsetParent?void 0:r.getOffsetParent(f));let P=R?R[v]:0;P&&await(null==r.isElement?void 0:r.isElement(R))||(P=s.floating[v]||o.floating[p]);const S=A/2-b/2,O=P/2-x[p]/2-1,T=e.min(g[y],O),D=e.min(g[w],O),E=T,C=P-x[p]-D,L=P/2-x[p]/2+S,k=e.clamp(E,L,C),j=!c.arrow&&null!=e.getAlignment(l)&&L!==k&&o.reference[p]/2-(L<E?T:D)-x[p]/2<0,B=j?L<E?L-E:L-C:0;return{[u]:d[u]+B,data:{[u]:k,centerOffset:L-k-B,...j&&{alignmentOffset:B}},reset:j}}}),exports.autoPlacement=function(t){return void 0===t&&(t={}),{name:"autoPlacement",options:t,async fn(i){var a,l,o;const{rects:r,middlewareData:s,placement:c,platform:f,elements:m}=i,{crossAxis:g=!1,alignment:d,allowedPlacements:u=e.placements,autoAlignment:p=!0,...x}=e.evaluate(t,i),h=void 0!==d||u===e.placements?function(t,n,i){return(t?[...i.filter((n=>e.getAlignment(n)===t)),...i.filter((n=>e.getAlignment(n)!==t))]:i.filter((t=>e.getSide(t)===t))).filter((i=>!t||e.getAlignment(i)===t||!!n&&e.getOppositeAlignmentPlacement(i)!==i))}(d||null,p,u):u,y=await n(i,x),w=(null==(a=s.autoPlacement)?void 0:a.index)||0,v=h[w];if(null==v)return{};const A=e.getAlignmentSides(v,r,await(null==f.isRTL?void 0:f.isRTL(m.floating)));if(c!==v)return{reset:{placement:h[0]}};const b=[y[e.getSide(v)],y[A[0]],y[A[1]]],R=[...(null==(l=s.autoPlacement)?void 0:l.overflows)||[],{placement:v,overflows:b}],P=h[w+1];if(P)return{data:{index:w+1,overflows:R},reset:{placement:P}};const S=R.map((t=>{const n=e.getAlignment(t.placement);return[t.placement,n&&g?t.overflows.slice(0,2).reduce(((e,t)=>e+t),0):t.overflows[0],t.overflows]})).sort(((e,t)=>e[1]-t[1])),O=(null==(o=S.filter((t=>t[2].slice(0,e.getAlignment(t[0])?2:3).every((e=>e<=0))))[0])?void 0:o[0])||S[0][0];return O!==c?{data:{index:w+1,overflows:R},reset:{placement:O}}:{}}}},exports.computePosition=async(e,n,i)=>{const{placement:a="bottom",strategy:l="absolute",middleware:o=[],platform:r}=i,s=o.filter(Boolean),c=await(null==r.isRTL?void 0:r.isRTL(n));let f=await r.getElementRects({reference:e,floating:n,strategy:l}),{x:m,y:g}=t(f,a,c),d=a,u={},p=0;for(let i=0;i<s.length;i++){const{name:o,fn:x}=s[i],{x:h,y:y,data:w,reset:v}=await x({x:m,y:g,initialPlacement:a,placement:d,strategy:l,middlewareData:u,rects:f,platform:r,elements:{reference:e,floating:n}});m=null!=h?h:m,g=null!=y?y:g,u={...u,[o]:{...u[o],...w}},v&&p<=50&&(p++,"object"==typeof v&&(v.placement&&(d=v.placement),v.rects&&(f=!0===v.rects?await r.getElementRects({reference:e,floating:n,strategy:l}):v.rects),({x:m,y:g}=t(f,d,c))),i=-1)}return{x:m,y:g,placement:d,strategy:l,middlewareData:u}},exports.detectOverflow=n,exports.flip=function(t){return void 0===t&&(t={}),{name:"flip",options:t,async fn(i){var a,l;const{placement:o,middlewareData:r,rects:s,initialPlacement:c,platform:f,elements:m}=i,{mainAxis:g=!0,crossAxis:d=!0,fallbackPlacements:u,fallbackStrategy:p="bestFit",fallbackAxisSideDirection:x="none",flipAlignment:h=!0,...y}=e.evaluate(t,i);if(null!=(a=r.arrow)&&a.alignmentOffset)return{};const w=e.getSide(o),v=e.getSide(c)===c,A=await(null==f.isRTL?void 0:f.isRTL(m.floating)),b=u||(v||!h?[e.getOppositePlacement(c)]:e.getExpandedPlacements(c));u||"none"===x||b.push(...e.getOppositeAxisPlacements(c,h,x,A));const R=[c,...b],P=await n(i,y),S=[];let O=(null==(l=r.flip)?void 0:l.overflows)||[];if(g&&S.push(P[w]),d){const t=e.getAlignmentSides(o,s,A);S.push(P[t[0]],P[t[1]])}if(O=[...O,{placement:o,overflows:S}],!S.every((e=>e<=0))){var T,D;const e=((null==(T=r.flip)?void 0:T.index)||0)+1,t=R[e];if(t)return{data:{index:e,overflows:O},reset:{placement:t}};let n=null==(D=O.filter((e=>e.overflows[0]<=0)).sort(((e,t)=>e.overflows[1]-t.overflows[1]))[0])?void 0:D.placement;if(!n)switch(p){case"bestFit":{var E;const e=null==(E=O.map((e=>[e.placement,e.overflows.filter((e=>e>0)).reduce(((e,t)=>e+t),0)])).sort(((e,t)=>e[1]-t[1]))[0])?void 0:E[0];e&&(n=e);break}case"initialPlacement":n=c}if(o!==n)return{reset:{placement:n}}}return{}}}},exports.hide=function(t){return void 0===t&&(t={}),{name:"hide",options:t,async fn(l){const{rects:o}=l,{strategy:r="referenceHidden",...s}=e.evaluate(t,l);switch(r){case"referenceHidden":{const e=i(await n(l,{...s,elementContext:"reference"}),o.reference);return{data:{referenceHiddenOffsets:e,referenceHidden:a(e)}}}case"escaped":{const e=i(await n(l,{...s,altBoundary:!0}),o.floating);return{data:{escapedOffsets:e,escaped:a(e)}}}default:return{}}}}},exports.inline=function(t){return void 0===t&&(t={}),{name:"inline",options:t,async fn(n){const{placement:i,elements:a,rects:o,platform:r,strategy:s}=n,{padding:c=2,x:f,y:m}=e.evaluate(t,n),g=Array.from(await(null==r.getClientRects?void 0:r.getClientRects(a.reference))||[]),d=function(t){const n=t.slice().sort(((e,t)=>e.y-t.y)),i=[];let a=null;for(let e=0;e<n.length;e++){const t=n[e];!a||t.y-a.y>a.height/2?i.push([t]):i[i.length-1].push(t),a=t}return i.map((t=>e.rectToClientRect(l(t))))}(g),u=e.rectToClientRect(l(g)),p=e.getPaddingObject(c);const x=await r.getElementRects({reference:{getBoundingClientRect:function(){if(2===d.length&&d[0].left>d[1].right&&null!=f&&null!=m)return d.find((e=>f>e.left-p.left&&f<e.right+p.right&&m>e.top-p.top&&m<e.bottom+p.bottom))||u;if(d.length>=2){if("y"===e.getSideAxis(i)){const t=d[0],n=d[d.length-1],a="top"===e.getSide(i),l=t.top,o=n.bottom,r=a?t.left:n.left,s=a?t.right:n.right;return{top:l,bottom:o,left:r,right:s,width:s-r,height:o-l,x:r,y:l}}const t="left"===e.getSide(i),n=e.max(...d.map((e=>e.right))),a=e.min(...d.map((e=>e.left))),l=d.filter((e=>t?e.left===a:e.right===n)),o=l[0].top,r=l[l.length-1].bottom;return{top:o,bottom:r,left:a,right:n,width:n-a,height:r-o,x:a,y:o}}return u}},floating:a.floating,strategy:s});return o.reference.x!==x.reference.x||o.reference.y!==x.reference.y||o.reference.width!==x.reference.width||o.reference.height!==x.reference.height?{reset:{rects:x}}:{}}}},exports.limitShift=function(t){return void 0===t&&(t={}),{options:t,fn(n){const{x:i,y:a,placement:l,rects:o,middlewareData:r}=n,{offset:s=0,mainAxis:c=!0,crossAxis:f=!0}=e.evaluate(t,n),m={x:i,y:a},g=e.getSideAxis(l),d=e.getOppositeAxis(g);let u=m[d],p=m[g];const x=e.evaluate(s,n),h="number"==typeof x?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(c){const e="y"===d?"height":"width",t=o.reference[d]-o.floating[e]+h.mainAxis,n=o.reference[d]+o.reference[e]-h.mainAxis;u<t?u=t:u>n&&(u=n)}if(f){var y,w;const t="y"===d?"width":"height",n=["top","left"].includes(e.getSide(l)),i=o.reference[g]-o.floating[t]+(n&&(null==(y=r.offset)?void 0:y[g])||0)+(n?0:h.crossAxis),a=o.reference[g]+o.reference[t]+(n?0:(null==(w=r.offset)?void 0:w[g])||0)-(n?h.crossAxis:0);p<i?p=i:p>a&&(p=a)}return{[d]:u,[g]:p}}}},exports.offset=function(t){return void 0===t&&(t=0),{name:"offset",options:t,async fn(n){var i,a;const{x:l,y:o,placement:r,middlewareData:s}=n,c=await async function(t,n){const{placement:i,platform:a,elements:l}=t,o=await(null==a.isRTL?void 0:a.isRTL(l.floating)),r=e.getSide(i),s=e.getAlignment(i),c="y"===e.getSideAxis(i),f=["left","top"].includes(r)?-1:1,m=o&&c?-1:1,g=e.evaluate(n,t);let{mainAxis:d,crossAxis:u,alignmentAxis:p}="number"==typeof g?{mainAxis:g,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...g};return s&&"number"==typeof p&&(u="end"===s?-1*p:p),c?{x:u*m,y:d*f}:{x:d*f,y:u*m}}(n,t);return r===(null==(i=s.offset)?void 0:i.placement)&&null!=(a=s.arrow)&&a.alignmentOffset?{}:{x:l+c.x,y:o+c.y,data:{...c,placement:r}}}}},exports.shift=function(t){return void 0===t&&(t={}),{name:"shift",options:t,async fn(i){const{x:a,y:l,placement:o}=i,{mainAxis:r=!0,crossAxis:s=!1,limiter:c={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...f}=e.evaluate(t,i),m={x:a,y:l},g=await n(i,f),d=e.getSideAxis(e.getSide(o)),u=e.getOppositeAxis(d);let p=m[u],x=m[d];if(r){const t="y"===u?"bottom":"right",n=p+g["y"===u?"top":"left"],i=p-g[t];p=e.clamp(n,p,i)}if(s){const t="y"===d?"bottom":"right",n=x+g["y"===d?"top":"left"],i=x-g[t];x=e.clamp(n,x,i)}const h=c.fn({...i,[u]:p,[d]:x});return{...h,data:{x:h.x-a,y:h.y-l}}}}},exports.size=function(t){return void 0===t&&(t={}),{name:"size",options:t,async fn(i){const{placement:a,rects:l,platform:o,elements:r}=i,{apply:s=(()=>{}),...c}=e.evaluate(t,i),f=await n(i,c),m=e.getSide(a),g=e.getAlignment(a),d="y"===e.getSideAxis(a),{width:u,height:p}=l.floating;let x,h;"top"===m||"bottom"===m?(x=m,h=g===(await(null==o.isRTL?void 0:o.isRTL(r.floating))?"start":"end")?"left":"right"):(h=m,x="end"===g?"top":"bottom");const y=p-f[x],w=u-f[h],v=!i.middlewareData.shift;let A=y,b=w;if(d){const t=u-f.left-f.right;b=g||v?e.min(w,t):t}else{const t=p-f.top-f.bottom;A=g||v?e.min(y,t):t}if(v&&!g){const t=e.max(f.left,0),n=e.max(f.right,0),i=e.max(f.top,0),a=e.max(f.bottom,0);d?b=u-2*(0!==t||0!==n?t+n:e.max(f.left,f.right)):A=p-2*(0!==i||0!==a?i+a:e.max(f.top,f.bottom))}await s({...i,availableWidth:b,availableHeight:A});const R=await o.getDimensions(r.floating);return u!==R.width||p!==R.height?{reset:{rects:!0}}:{}}}};
//# sourceMappingURL=floating-ui.core.mjs.js.map
