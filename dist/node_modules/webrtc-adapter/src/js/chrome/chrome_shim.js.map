{"version":3,"file":"chrome_shim.js","sources":["../../../../../../node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js"],"sourcesContent":["/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\n\nexport {shimGetUserMedia} from './getusermedia';\n\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n    .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n        this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n        externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n        internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n        .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n    window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n    'localDescription', {\n      get() {\n        const description = origLocalDescription.get.apply(this);\n        if (description.type === '') {\n          return description;\n        }\n        return replaceInternalStreamId(this, description);\n      }\n    });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n          'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n      .forEach(function(method) {\n        const nativeMethod = window.RTCPeerConnection.prototype[method];\n        const methodObj = {[method]() {\n          arguments[0] = new ((method === 'addIceCandidate') ?\n            window.RTCIceCandidate :\n            window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }};\n        window.RTCPeerConnection.prototype[method] = methodObj[method];\n      });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || (pc.getConfiguration &&\n        pc.getConfiguration().sdpSemantics === 'plan-b')) {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n"],"names":["shimAddTrackRemoveTrackWithNative","window","RTCPeerConnection","prototype","getLocalStreams","this","_shimmedLocalStreams","Object","keys","map","streamId","origAddTrack","addTrack","track","stream","apply","arguments","sender","id","indexOf","push","origAddStream","addStream","getTracks","forEach","getSenders","find","s","DOMException","existingSenders","newSenders","filter","newSender","concat","origRemoveStream","removeStream","origRemoveTrack","removeTrack","idx","splice","length","browserDetails","utils","e","pc","target","version","getConfiguration","sdpSemantics","signalingState","origGetLocalStreams","nativeStreams","_reverseStreams","_streams","newStream","MediaStream","replaceInternalStreamId","description","sdp","internalId","externalStream","internalStream","replace","RegExp","RTCSessionDescription","type","streams","slice","call","t","oldStream","Promise","resolve","then","dispatchEvent","Event","method","nativeMethod","methodObj","args","desc","err","origSetLocalDescription","setLocalDescription","replaceExternalStreamId","origLocalDescription","getOwnPropertyDescriptor","defineProperty","get","_pc","streamid","shimSenderWithDtmf","dtmf","undefined","_dtmf","kind","createDTMFSender","_senders","RTCRtpSender","origGetSenders","senders","webkitMediaStream","_ontrack","set","f","removeEventListener","addEventListener","enumerable","configurable","origSetRemoteDescription","setRemoteDescription","_ontrackpoly","te","receiver","getReceivers","r","event","transceiver","value","webkitRTCPeerConnection","RTCIceCandidate","RTCRtpReceiver","getStats","result","origGetReceivers","receivers","srcElement","filterStats","origGetStats","MediaStreamTrack","reject"],"mappings":"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"}