{"version":3,"file":"messages.js","sources":["../../../src/lib/webrtc/messages.ts"],"sourcesContent":["// Copyright (C) 2024 Nethesis S.r.l.\n// SPDX-License-Identifier: AGPL-3.0-or-later\n\nimport Janus from './janus'\nimport { store } from '../../store'\nimport adapter from 'webrtc-adapter'\nimport { getCurrentAudioInputDeviceId, getSupportedDevices } from '../devices/devices'\nimport { getJSONItem } from '../../utils'\nimport { JanusTrack } from '../../types'\n\nexport function register({\n  sipExten,\n  sipSecret,\n  sipHost,\n  sipPort,\n}: {\n  sipExten: string\n  sipSecret: string\n  sipHost: string\n  sipPort: string\n}) {\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  const { name } = store.getState().currentUser\n  if (sipcall) {\n    sipcall.send({\n      message: {\n        request: 'register',\n        username: `sip:${sipExten}@${sipHost}`,\n        display_name: name || '',\n        secret: sipSecret,\n        proxy: `sip:${sipHost}:${sipPort}`,\n        outbound_proxy: `sip:${sipHost}:${sipPort}`,\n        sips: false,\n        refresh: false,\n      },\n    })\n  }\n}\n\nexport function answerWebRTC() {\n  const { sipcall, jsepGlobal }: { sipcall: any; jsepGlobal: any } = store.getState().webrtc\n  if (sipcall && jsepGlobal) {\n    let currentAudioInputDeviceId = getCurrentAudioInputDeviceId()\n    const tracks: any[] = []\n\n    if (currentAudioInputDeviceId) {\n      tracks.push({\n        type: 'audio',\n        capture: { deviceId: { exact: currentAudioInputDeviceId } },\n        recv: true,\n      })\n    } else {\n      tracks.push({ type: 'audio', capture: true, recv: true })\n    }\n\n    // For incoming calls, directly create an answer without first calling handleRemoteJsep\n    // because Janus has already provided us with an offer\n    try {\n      sipcall.createAnswer({\n        jsep: jsepGlobal,\n        tracks: tracks,\n        success: (jsep) => {\n          sipcall.send({\n            message: {\n              request: 'accept',\n            },\n            jsep: jsep,\n          })\n        },\n        error: (error) => {\n          // If there's an error during createAnswer, check if it's error 469 (Unexpected ANSWER)\n          // @ts-ignore\n          Janus.error('WebRTC error:', error)\n\n          // Check if the error contains code 469 or the message \"Unexpected ANSWER\"\n          if (\n            error &&\n            ((typeof error === 'object' && error.code === 469) ||\n              (typeof error === 'string' && error.includes('Unexpected ANSWER')))\n          ) {\n            console.warn('Got \"Unexpected ANSWER\" error, forcing the answer anyway')\n            // Force sending the accept message even without JSEP\n            sipcall.send({\n              message: {\n                request: 'accept',\n              },\n            })\n          } else {\n            // For other types of errors, decline the call\n            sipcall.send({\n              message: {\n                request: 'decline',\n                code: 480,\n              },\n            })\n          }\n        },\n      })\n    } catch (error) {\n      console.error('Exception in createAnswer:', error)\n\n      // Even in case of an exception, try to accept the call\n      sipcall.send({\n        message: {\n          request: 'accept',\n        },\n      })\n    }\n  }\n}\n\nexport function decline() {\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  if (sipcall) {\n    sipcall.send({\n      message: {\n        request: 'decline',\n      },\n    })\n  }\n}\n\nexport function hangup() {\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  if (sipcall) {\n    sipcall.send({\n      message: {\n        request: 'hangup',\n      },\n    })\n  }\n}\n\nexport function unregister() {\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  if (sipcall) {\n    sipcall.send({\n      message: {\n        request: 'unregister',\n      },\n    })\n  }\n}\n\nexport function detach() {\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  if (sipcall) {\n    return sipcall.detach()\n  }\n}\n\nexport function handleRemote(jsep: any) {\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  if (sipcall) {\n    sipcall.handleRemoteJsep({\n      jsep: jsep,\n      error: function (error) {\n        console.error('WebRTC error... ' + JSON.stringify(error))\n\n        var hangup = {\n          request: 'hangup',\n        }\n        sipcall.send({\n          message: hangup,\n        })\n        sipcall.hangup()\n      },\n    })\n  }\n}\n\nexport function callSipURI(sipURI: string) {\n  getSupportedDevices(async () => {\n    // @ts-ignore\n    Janus.log('This is a SIP call')\n\n    let currentAudioInputDeviceId = getCurrentAudioInputDeviceId()\n\n    const tracks: JanusTrack[] = []\n\n    if (currentAudioInputDeviceId) {\n      tracks.push({\n        type: 'audio',\n        capture: { deviceId: { exact: currentAudioInputDeviceId } },\n        recv: true,\n      })\n    } else {\n      tracks.push({ type: 'audio', capture: true, recv: true })\n    }\n\n    await call(sipURI, tracks)\n  })\n}\n\nexport function call(sipURI: string, tracks: JanusTrack[]) {\n  return new Promise((resolve, reject) => {\n    const { sipcall }: { sipcall: any } = store.getState().webrtc\n\n    sipcall.createOffer({\n      tracks: tracks,\n      success: function (jsep: any) {\n        // @ts-ignore\n        Janus.debug('Got SDP!')\n        // @ts-ignore\n        Janus.debug(jsep)\n        sipcall.send({\n          message: {\n            request: 'call',\n            uri: sipURI,\n          },\n          jsep: jsep,\n        })\n        resolve(true)\n      },\n      error: function (error) {\n        // @ts-ignore\n        Janus.error('WebRTC error...', error)\n        // @ts-ignore\n        Janus.error('WebRTC error call on createOffer: ', error)\n        reject(false)\n      },\n    })\n  })\n}\n\n/**\n * Mute current call so the counterpart can't listen the current user\n * @returns The muted status\n */\nexport function muteWebRTC(): boolean {\n  // Initialize sipcall\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  // Uset the janus library functions to mute call\n  sipcall.muteAudio()\n  return sipcall.isAudioMuted()\n}\n\n/**\n * Unmute current call so the counterpart can listen the current user\n * @returns The muted status\n */\nexport function unmuteWebRTC(): boolean {\n  // Initialize sipcall\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  // Use the janus library functions to unmute call\n  sipcall.unmuteAudio()\n  return !sipcall.isAudioMuted()\n}\n\n/**\n * Pause current call so the counterpart listens the pause ringtone\n * @returns The true if no errors occurs\n */\nexport function pauseWebRTC() {\n  // Initialize sipcall\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  // Send hold message\n  try {\n    sipcall.send({\n      message: {\n        request: 'hold',\n      },\n    })\n    return true\n  } catch (err) {\n    console.error(err)\n    return false\n  }\n}\n\n/**\n * Unpause the current call so the counterpart listens the current user\n * @returns The true if no errors occurs\n */\nexport function unpauseWebRTC() {\n  // Initialize sipcall\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  // Send hold message\n  try {\n    sipcall.send({\n      message: {\n        request: 'unhold',\n      },\n    })\n    return true\n  } catch (err) {\n    console.error(err)\n    return false\n  }\n}\n\n/**\n * Send DTMF messages to Janus\n */\nexport function sendDTMF(key: string) {\n  // Initialize sipcall\n  const { sipcall }: { sipcall: any } = store.getState().webrtc\n  if (adapter.browserDetails.browser === 'chrome') {\n    sipcall.dtmf({\n      dtmf: {\n        tones: key,\n      },\n    })\n  } else {\n    sipcall.send({\n      message: {\n        request: 'dtmf_info',\n        digit: `${key}`,\n      },\n    })\n  }\n}\n"],"names":["call","sipURI","tracks","Promise","resolve","reject","sipcall","store","getState","webrtc","createOffer","success","jsep","Janus","debug","send","message","request","uri","error","_a","jsepGlobal","currentAudioInputDeviceId","getCurrentAudioInputDeviceId","push","type","capture","deviceId","exact","recv","createAnswer","code","includes","console","warn","_this","this","getSupportedDevices","__awaiter","log","sent","detach","handleRemoteJsep","JSON","stringify","hangup","muteAudio","isAudioMuted","err","sipExten","sipSecret","sipHost","sipPort","name","currentUser","username","concat","display_name","secret","proxy","outbound_proxy","sips","refresh","key","adapter","browserDetails","browser","dtmf","tones","digit","unmuteAudio"],"mappings":"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"}