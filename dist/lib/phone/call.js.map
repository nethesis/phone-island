{"version":3,"file":"call.js","sources":["../../../src/lib/phone/call.ts"],"sourcesContent":["// Copyright (C) 2024 Nethesis S.r.l.\n// SPDX-License-Identifier: AGPL-3.0-or-later\n\nimport {\n  callSipURI,\n  hangup,\n  answerWebRTC,\n  muteWebRTC,\n  unmuteWebRTC,\n  pauseWebRTC,\n  unpauseWebRTC,\n} from '../webrtc/messages'\nimport { Dispatch, store } from '../../store'\nimport { isWebRTC } from '../user/default_device'\nimport {\n  blindTransfer as blindTransferRequest,\n  attendedTransfer as attendedTransferRequest,\n  hangupPhysical,\n  answerPhysical,\n  mutePhysical,\n  pausePhysical,\n  callPhysical,\n  toggleRecord,\n  hangupPhysicalRecordingCall,\n  startConf,\n  joinMyConf,\n  endConf,\n  muteUserConf,\n  unmuteUserConf,\n  hangupUserConf,\n  forceHangup,\n} from '../../services/astproxy'\nimport dtmfAudios from '../../static/dtmf'\nimport { hangupConversation, parkConversation } from '../../services/astproxy'\nimport { eventDispatch } from '../../utils'\nimport { isEmpty } from '../../utils/genericFunctions/isEmpty'\nimport { getStreamingSourceId } from '../../utils/streaming/getStreamingSourceId'\nimport { unsubscribe } from '../../services/user'\n\n/**\n * Starts a call to a number\n * @param number The number string\n */\nexport function callNumber(number: string, sipHost: string) {\n  const sipURI = `sip:${number}@${sipHost}`\n  if (isWebRTC()) {\n    callSipURI(sipURI)\n  } else {\n    callPhysical(number)\n  }\n\n  eventDispatch('phone-island-call-started', {})\n}\n\n/**\n * Answer incoming call\n */\nexport function answerIncomingCall() {\n  if (isWebRTC()) {\n    answerWebRTC()\n  } else {\n    answerPhysical()\n  }\n}\n\n/**\n * Hangup all the conversations of all the extensions of the current user\n */\nexport function hangupAllExtensions() {\n  // Get current user endpoints\n  const { conversations } = store.getState().currentUser\n  // Hangup all the conversations of all extensions of the current user\n  for (const extension in conversations) {\n    const conversationsIds = Object.keys(conversations[extension])\n    conversationsIds.forEach((id) => {\n      hangupConversation({\n        convid: id,\n        endpointId: extension,\n      })\n    })\n  }\n}\n\nexport function forceHangupConversation() {\n  // Get current user endpoints\n  const { conversations } = store.getState().currentUser\n  // Hangup all the conversations of all extensions of the current user\n  for (const extension in conversations) {\n    const conversationsIds = Object.keys(conversations[extension])\n    conversationsIds.forEach((id) => {\n      forceHangup({\n        convid: id,\n        endpointId: extension,\n        endpointType: 'extension',\n      })\n    })\n  }\n}\n\n/**\n * Hangup current call\n */\nexport function hangupCurrentCall() {\n  const { outgoing, accepted, streamingSourceNumber } = store.getState().currentCall\n  const { isFromStreaming } = store.getState().island\n  \n  if (outgoing || accepted) {\n    if (isWebRTC()) {\n      hangup()\n    } else {\n      hangupPhysical()\n    }\n    store.dispatch.player.stopAudioPlayer()\n    store.dispatch.currentCall.reset()\n    store.dispatch.listen.reset()\n    \n    // If call was from a streaming source, unsubscribe and clear images\n    if (isFromStreaming && streamingSourceNumber) {\n      const sourceId = getStreamingSourceId(streamingSourceNumber)\n      if (sourceId) {\n        // Unsubscribe from streaming updates\n        unsubscribe({ id: sourceId })\n          .then(() => console.debug(`Unsubscribed from streaming source: ${sourceId}`))\n          .catch(error => console.error('Error unsubscribing from streaming source:', error))\n        \n        // Clear source images to free up memory\n        store.dispatch.streaming.clearSourceImages()\n      }\n    }\n    \n    // Reset isFromStreaming flag\n    store.dispatch.island.setIsFromStreaming(false)\n  }\n  // Caller close the call before the call is accepted\n  eventDispatch('phone-island-call-ended', {})\n}\n\n/**\n * Hangup current physical recording\n */\nexport function hangupCurrentPhysicalRecording() {\n  hangupPhysicalRecordingCall()\n  store.dispatch.player.stopAudioPlayer()\n  store.dispatch.physicalRecorder.reset()\n  store.dispatch.physicalRecorder.setRecording(false)\n  store.dispatch.island.setIslandView(null)\n  store.dispatch.listen.reset()\n  // Caller close the call before the call is accepted\n  eventDispatch('phone-island-call-ended', {})\n}\n\n/**\n * Mute the current call\n */\nexport function muteCurrentCall() {\n  // Check the current user default device\n  if (isWebRTC()) {\n    const muted = muteWebRTC()\n    if (muted) {\n      store.dispatch.currentCall.updateCurrentCall({\n        muted: true,\n      })\n    }\n  } else {\n    mutePhysical(true)\n  }\n  eventDispatch('phone-island-call-muted', {})\n}\n\n/**\n * Unmute the current call\n */\nexport function unmuteCurrentCall() {\n  // Check the current user default device\n  if (isWebRTC()) {\n    const unmuted = unmuteWebRTC()\n    if (unmuted) {\n      store.dispatch.currentCall.updateCurrentCall({\n        muted: false,\n      })\n    }\n  } else {\n    mutePhysical(false)\n  }\n  eventDispatch('phone-island-call-unmuted', {})\n}\n\n/**\n * Pause the current call\n */\nexport function pauseCurrentCall() {\n  // Check the current user default device\n  if (isWebRTC()) {\n    const paused = pauseWebRTC()\n    if (paused) {\n      store.dispatch.currentCall.updateCurrentCall({\n        paused: true,\n      })\n      // Pause remote audio\n      store.dispatch.player.pauseRemoteAudio()\n    }\n  } else {\n    pausePhysical(true)\n  }\n  eventDispatch('phone-island-call-held', {})\n}\n\n/**\n * Unpause the current call\n */\nexport function unpauseCurrentCall() {\n  // Check the current user default device\n  if (isWebRTC()) {\n    const unpaused = unpauseWebRTC()\n    if (unpaused) {\n      store.dispatch.currentCall.updateCurrentCall({\n        paused: false,\n      })\n      // Play remote audio\n      store.dispatch.player.playRemoteAudio()\n    }\n  } else {\n    pausePhysical(false)\n  }\n  eventDispatch('phone-island-call-unheld', {})\n}\n\n/**\n * Transfer the current call through a blind transfer (not in use)\n */\nexport async function blindTransferFunction(number: string, endpointIdInConversation: string) {\n  // Retrieve current conversation info\n  const { conversationId } = store.getState().currentCall\n  // Transfer the call through blind transfer\n  if (conversationId && endpointIdInConversation && number) {\n    return await blindTransferRequest({\n      convid: conversationId,\n      to: number,\n      endpointId: endpointIdInConversation,\n    })\n  }\n}\n\n/**\n * Transfer the current call through a attended transfer\n */\nexport async function attendedTransfer(number: string) {\n  // Retrieve current conversation info\n  const { conversationId } = store.getState().currentCall\n  const { default_device } = store.getState().currentUser\n  let default_device_details = default_device?.id || default_device?.exten\n  // Transfer the call through attended transfer\n  if (conversationId && default_device_details && number) {\n    return await attendedTransferRequest({\n      convid: conversationId,\n      to: number,\n      endpointId: default_device_details,\n    })\n  }\n}\n\n/**\n * Play the dtmf audio files\n */\nexport function playDtmfAudio(key: string) {\n  if (key === '*') key = 'star'\n  if (key === '#') key = 'pound'\n  store.dispatch.player.updateStartAudioPlayer({ src: dtmfAudios[`dtmf_${key}`] })\n}\n\n/**\n * Park the current call\n */\nexport function parkCurrentCall() {\n  const conversationId = store?.getState()?.currentCall?.conversationId\n  const userConversationInformations = store?.getState()?.currentUser?.conversations\n\n  let parkingInformation: any = {}\n\n  if (conversationId) {\n    if (userConversationInformations) {\n      for (const key in userConversationInformations) {\n        if (userConversationInformations.hasOwnProperty(key)) {\n          const conversation = userConversationInformations[key]\n          if (Object.keys(conversation).length > 0) {\n            parkingInformation = {\n              numberParkId: key,\n              idConversation: conversationId,\n            }\n          }\n        }\n      }\n    }\n\n    if (Object.keys(parkingInformation).length > 0) {\n      if (parkingInformation?.numberParkId) {\n        // If park information are not empty park call\n        parkConversation({\n          applicantId: parkingInformation?.numberParkId,\n          convid: conversationId,\n          endpointId: parkingInformation?.numberParkId,\n        })\n\n        store.dispatch.currentCall.setParked(true)\n\n        eventDispatch('phone-island-call-parked', {})\n      }\n    }\n  }\n}\n\nconst findFirstExtesnionNotEmpty = (data) => {\n  for (const key in data) {\n    if (Object.keys(data[key]).length !== 0) {\n      const firstEntry: any = Object.values(data[key])[0]\n      return {\n        id: firstEntry.id,\n        recording: firstEntry.recording,\n      }\n    }\n  }\n  return null\n}\n\nexport async function recordCurrentCall(recordingValue: boolean) {\n  store.dispatch.currentCall.updateRecordingStatus(!recordingValue)\n  const userConversationInformations = store?.getState()?.currentUser?.conversations\n\n  const firstExtensionNotEmpty = findFirstExtesnionNotEmpty(userConversationInformations)\n\n  if (!firstExtensionNotEmpty) {\n    return\n  } else {\n    const numberToSendCall = firstExtensionNotEmpty?.id?.match(/\\/(\\d+)-/)\n    const endpointId = numberToSendCall[1]\n\n    const listenInformations = {\n      convid: firstExtensionNotEmpty?.id?.toString(),\n      endpointId: endpointId?.toString(),\n    }\n\n    let recordingValues = ''\n    switch (firstExtensionNotEmpty?.recording) {\n      case 'false':\n        recordingValues = 'start_record'\n        break\n      case 'true':\n        recordingValues = 'mute_record'\n        break\n      case 'mute':\n        recordingValues = 'unmute_record'\n        break\n      default:\n        recordingValues = ''\n        break\n    }\n\n    if (listenInformations) {\n      try {\n        await toggleRecord(recordingValues, listenInformations)\n      } catch (e) {\n        console.error(e)\n        return []\n      }\n    }\n  }\n}\n\nexport async function startConference() {\n  const {\n    accepted,\n    chSource,\n    chDest,\n    incoming,\n    outgoing,\n    incomingSocket,\n    outgoingSocket,\n    conversationId,\n  }: any = store?.getState()?.currentCall\n  const { default_device } = store.getState().currentUser\n  const defaultDeviceId = default_device?.id || default_device?.exten\n  let addedUserExtension = ''\n  if (accepted && (incoming || incomingSocket) && !isEmpty(chSource)) {\n    addedUserExtension = chSource?.callerNum\n  } else if (accepted && (outgoing || outgoingSocket) && !isEmpty(chDest)) {\n    addedUserExtension = chDest?.callerNum\n  }\n\n  if (defaultDeviceId !== '' && conversationId !== '' && addedUserExtension !== '') {\n    const startConferenceInformations = {\n      convid: conversationId?.toString(),\n      addEndpointId: addedUserExtension?.toString(),\n      ownerEndpointId: defaultDeviceId?.toString(),\n    }\n\n    if (startConferenceInformations) {\n      try {\n        const result = await startConf(startConferenceInformations)\n        if (result) {\n          // Set conferencing and disable pause\n          store.dispatch.currentCall.updateCurrentCall({\n            conferencing: true,\n            paused: false,\n          })\n\n          eventDispatch('phone-island-call-conferenced', {})\n          return true\n        }\n        return false\n      } catch (e) {\n        console.error(e)\n        return false\n      }\n    }\n  }\n  return false\n}\n\nexport async function joinConference() {\n  const { default_device } = store.getState().currentUser\n  const defaultDeviceId = default_device?.id || default_device?.exten\n\n  if (defaultDeviceId !== '') {\n    const joinConferenceInformation = {\n      endpointId: defaultDeviceId?.toString(),\n    }\n\n    if (joinConferenceInformation) {\n      try {\n        const result = await joinMyConf(joinConferenceInformation)\n        if (result) {\n          eventDispatch('phone-island-owner-conference-enter', {})\n          return true\n        }\n        return false\n      } catch (e) {\n        console.error(e)\n        return false\n      }\n    }\n  }\n  return false\n}\n\nexport async function endConference() {\n  const { conferenceId } = store.getState().conference\n\n  if (conferenceId !== '') {\n    const endConferenceInformation = {\n      confId: conferenceId?.toString(),\n    }\n\n    if (endConferenceInformation) {\n      try {\n        const result = await endConf(endConferenceInformation)\n        if (result) {\n          eventDispatch('phone-island-owner-conference-finished', {})\n          return true\n        }\n        return false\n      } catch (e) {\n        console.error(e)\n        return false\n      }\n    }\n  }\n  return false\n}\n\nexport async function muteUserConference(confId, userId, isAlreadyMuted) {\n  if (confId === '' || userId === '') {\n    return false\n  }\n\n  const muteUnmuteUserInformation = {\n    confId: confId?.toString(),\n    userId: userId?.toString(),\n  }\n\n  try {\n    // Check if the user is already muted\n    const actionFunction = isAlreadyMuted ? unmuteUserConf : muteUserConf\n    const result = await actionFunction(muteUnmuteUserInformation)\n    return !!result\n  } catch (e) {\n    console.error(e)\n    return false\n  }\n}\n\nexport async function muteAllUsersConference(confId, isAlreadyMuted) {\n  if (confId === '') {\n    return false\n  }\n\n  // Get the conference users from the store\n  const { usersList } = store.getState().conference\n\n  if (!usersList || Object.keys(usersList).length === 0) {\n    return false\n  }\n\n  try {\n    // Iterate through all users (except the owner) and mute/unmute them\n    const nonOwnerUsers = Object.values(usersList)\n\n    // Determine which function to use based on isAlreadyMuted\n    const actionFunction = isAlreadyMuted ? unmuteUserConf : muteUserConf\n\n    // For each user, call the appropriate function directly\n    for (const user of nonOwnerUsers) {\n      const muteUnmuteUserInformation = {\n        confId: confId?.toString(),\n        userId: user.id?.toString(),\n      }\n\n      const result = await actionFunction(muteUnmuteUserInformation)\n\n      if (result) {\n        store.dispatch.conference.toggleUserMuted({\n          extenId: user.extenId,\n          muted: !isAlreadyMuted,\n        })\n      }\n    }\n\n    return true\n  } catch (e) {\n    console.error(e)\n    return false\n  }\n}\n\nexport async function removeUserConference(conferenceId, extensionId) {\n  if (conferenceId !== '' && extensionId !== '') {\n    const removeUserInformation = {\n      confId: conferenceId?.toString(),\n      extenId: extensionId?.toString(),\n    }\n\n    if (removeUserInformation) {\n      try {\n        const result = await hangupUserConf(removeUserInformation)\n        if (result) {\n          // Check if this was the last participant (excluding owner)\n          setTimeout(async () => {\n            const { usersList } = store.getState().conference\n            const remainingParticipants = Object.values(usersList || {}).filter(\n              (user) => !user.owner && user.extenId !== extensionId,\n            ).length\n\n            // If no more participants left, end the conference\n            if (remainingParticipants === 0) {\n              await endConference()\n            }\n          }, 500)\n\n          return true\n        }\n\n        return false\n      } catch (e) {\n        console.error(e)\n        return false\n      }\n    }\n  }\n  return false\n}\n\nexport const clickTransferOrConference = async (number: string, dispatch: Dispatch) => {\n  if (isInsideConferenceList()) {\n    const { isActive } = store.getState().conference\n    // Put current call user inside conference mode (only for first user to add not for the second one)\n    if (!isActive) {\n      const conferenceStarted = await startConference()\n      if (conferenceStarted) {\n        waitingConferenceView(number, dispatch)\n      }\n    } else {\n      waitingConferenceView(number, dispatch)\n    }\n  } else {\n    handleAttendedTransfer(number, dispatch)\n  }\n}\n\nexport const isInsideConferenceList = () => {\n  const { isConferenceList } = store.getState().island\n  if (isConferenceList) {\n    return true\n  }\n  return false\n}\n\nexport const waitingConferenceView = (numberToCall, dispatch: Dispatch) => {\n  const { username }: any = store.getState().currentUser\n  const { isActive, isOwnerInside } = store.getState().conference\n\n  // show current waiting user in back view ( only on first)\n  if (!isActive) {\n    dispatch.conference.setConferenceActive(true)\n    dispatch.conference.setConferenceStartedFrom(username)\n  }\n  // start new call with selected user from conference list\n  if (isOwnerInside) {\n    // if owner has already started the conference hangup before make a new call\n    hangupCurrentCall()\n    dispatch.conference.toggleIsOwnerInside(false)\n\n    // Use requestAnimationFrame to ensure state updates are complete before dispatching event\n    requestAnimationFrame(() => {\n      setTimeout(() => {\n        eventDispatch('phone-island-call-start', { number: numberToCall })\n      }, 800)\n    })\n  } else {\n    // Use requestAnimationFrame to ensure state updates are complete before dispatching event\n    requestAnimationFrame(() => {\n      setTimeout(() => {\n        eventDispatch('phone-island-call-start', { number: numberToCall })\n      }, 800)\n    })\n  }\n}\n\nexport async function handleAttendedTransfer(number: string, dispatch: Dispatch) {\n  // Send attended transfer message\n  unpauseCurrentCall()\n  const transferringMessageSent = await attendedTransfer(number)\n  if (transferringMessageSent) {\n    // Set transferring and disable pause\n    dispatch.currentCall.updateCurrentCall({\n      transferring: true,\n      paused: false,\n    })\n\n    // Use requestAnimationFrame to ensure state update is complete before audio operations\n    requestAnimationFrame(() => {\n      dispatch.player.playRemoteAudio()\n      eventDispatch('phone-island-call-transfered', {})\n    })\n  }\n}\n"],"names":["hangupCurrentCall","_a","store","getState","currentCall","outgoing","accepted","streamingSourceNumber","isFromStreaming","island","isWebRTC","hangup","hangupPhysical","dispatch","player","stopAudioPlayer","reset","listen","sourceId_1","getStreamingSourceId","unsubscribe","id","then","console","debug","concat","catch","error","streaming","clearSourceImages","setIsFromStreaming","eventDispatch","unpauseCurrentCall","unpauseWebRTC","updateCurrentCall","paused","playRemoteAudio","pausePhysical","attendedTransfer","number","conversationId","default_device","currentUser","default_device_details","exten","attendedTransferRequest","convid","to","endpointId","startConference","_b","chSource","chDest","incoming","incomingSocket","outgoingSocket","defaultDeviceId","addedUserExtension","isEmpty","callerNum","startConferenceInformations","toString","addEndpointId","ownerEndpointId","startConf","_c","sent","conferencing","e_2","endConference","conferenceId","conference","endConferenceInformation","confId","endConf","e_4","isInsideConferenceList","isConferenceList","waitingConferenceView","numberToCall","username","isActive","isOwnerInside","setConferenceActive","setConferenceStartedFrom","toggleIsOwnerInside","requestAnimationFrame","setTimeout","handleAttendedTransfer","transferring","answerWebRTC","answerPhysical","endpointIdInConversation","blindTransferRequest","sipHost","sipURI","callSipURI","callPhysical","__awaiter","conversations","extension","Object","keys","forEach","forceHangup","endpointType","hangupConversation","hangupPhysicalRecordingCall","physicalRecorder","setRecording","setIslandView","joinConferenceInformation","joinMyConf","e_3","isAlreadyMuted","usersList","length","nonOwnerUsers","values","actionFunction","unmuteUserConf","muteUserConf","_i","nonOwnerUsers_1","user","muteUnmuteUserInformation","userId","toggleUserMuted","extenId","muted","e_6","muteWebRTC","mutePhysical","e_5","userConversationInformations","_d","parkingInformation","key","hasOwnProperty","conversation","numberParkId","idConversation","parkConversation","applicantId","setParked","pauseWebRTC","pauseRemoteAudio","updateStartAudioPlayer","src","dtmfAudios","recordingValue","updateRecordingStatus","firstExtensionNotEmpty","data","firstEntry","recording","findFirstExtesnionNotEmpty","numberToSendCall","match","listenInformations","recordingValues","toggleRecord","_e","e_1","extensionId","removeUserInformation","hangupUserConf","_this","remainingParticipants","filter","owner","e_7","unmuteWebRTC"],"mappings":"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"}